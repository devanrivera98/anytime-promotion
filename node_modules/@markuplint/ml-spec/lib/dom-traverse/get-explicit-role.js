"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExplicitRole = void 0;
const get_role_spec_1 = require("../specs/get-role-spec");
const resolve_namespace_1 = require("../utils/resolve-namespace");
const get_permitted_roles_1 = require("./get-permitted-roles");
function getExplicitRole(specs, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, version) {
    var _a;
    const roleValue = el.getAttribute('role');
    const roleNames = (_a = roleValue === null || roleValue === void 0 ? void 0 : roleValue.toLowerCase().trim().split(/\s+/g)) !== null && _a !== void 0 ? _a : [];
    const permittedRoles = (0, get_permitted_roles_1.getPermittedRoles)(el, version, specs);
    const { namespaceURI } = (0, resolve_namespace_1.resolveNamespace)(el.localName, el.namespaceURI);
    let error = 'NO_EXPLICIT';
    /**
     * Resolve from values and **Handling Author Errors**
     *
     * @see https://w3c.github.io/aria/#document-handling_author-errors
     */
    for (const roleName of roleNames) {
        const spec = (0, get_role_spec_1.getRoleSpec)(specs, roleName, namespaceURI, version);
        /**
         * If `spec` is null, the role DOES NOT EXIST.
         *
         * > If the role attribute contains no tokens matching the name
         * > of a non-abstract WAI-ARIA role,
         * > the user agent MUST treat the element as
         * > if no role had been provided. For example,
         * > <table role="foo"> should be exposed
         * > in the same way as <table> and <input type="text" role="structure">
         * > in the same way as <input type="text">.
         */
        if (!spec) {
            error = 'ROLE_NO_EXISTS';
            continue;
        }
        /**
         * > As stated in the Definition of Roles section,
         * > it is considered an authoring error to use abstract roles in content.
         * > User agents MUST NOT map abstract roles
         * > via the standard role mechanism of the accessibility API.
         */
        if (spec.isAbstract) {
            error = 'ABSTRACT';
            continue;
        }
        /**
         * Whether the role is the permitted role according to ARIA in HTML.
         */
        if (!permittedRoles.some(r => r.name === roleName)) {
            error = 'NO_PERMITTED';
            continue;
        }
        /**
         * > Certain landmark roles require names from authors.
         * > In situations where an author has not specified names for these landmarks,
         * > it is considered an authoring error.
         * > The user agent MUST treat such elements as if no role had been provided.
         * > If a valid fallback role had been specified,
         * > or if the element had an implicit ARIA role,
         * > then user agents would continue to expose that role, instead.
         */
        if (isLandmarkRole(spec) && !isValidLandmarkRole(el, spec)) {
            error = 'INVALID_LANDMARK';
            continue;
        }
        /**
         * Otherwise
         */
        return {
            el,
            role: {
                ...spec,
                isImplicit: false,
            },
        };
    }
    return {
        el,
        role: null,
        errorType: error,
    };
}
exports.getExplicitRole = getExplicitRole;
function isLandmarkRole(role) {
    return role === null || role === void 0 ? void 0 : role.superClassRoles.some(su => su.name === 'landmark');
}
function isValidLandmarkRole(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, role) {
    if (!role.accessibleNameRequired) {
        return true;
    }
    if (role.accessibleNameFromAuthor) {
        if (el.getAttribute('aria-label')) {
            return true;
        }
        const id = el.getAttribute('aria-labelledby');
        if (id && el.ownerDocument.getElementById(id)) {
            return true;
        }
    }
    // The landmark role does not require names from the content
    // if (role.accessibleNameFromContent) {}
    return false;
}
