"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComputedRole = void 0;
const aria_specs_1 = require("../specs/aria-specs");
const is_presentational_1 = require("../specs/is-presentational");
const accname_computation_1 = require("./accname-computation");
const get_attr_specs_1 = require("./get-attr-specs");
const get_explicit_role_1 = require("./get-explicit-role");
const get_implicit_role_1 = require("./get-implicit-role");
const get_non_presentational_ancestor_1 = require("./get-non-presentational-ancestor");
const has_required_owned_elements_1 = require("./has-required-owned-elements");
const matches_context_role_1 = require("./matches-context-role");
const may_be_focusable_1 = require("./may-be-focusable");
function getComputedRole(specs, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, version, assumeSingleNode = false) {
    var _a, _b, _c, _d;
    const implicitRole = (0, get_implicit_role_1.getImplicitRole)(specs, el, version);
    const explicitRole = (0, get_explicit_role_1.getExplicitRole)(specs, el, version);
    const computedRole = explicitRole.role
        ? explicitRole
        : {
            ...implicitRole,
            errorType: explicitRole.errorType === 'NO_EXPLICIT' ? undefined : explicitRole.errorType,
        };
    if (assumeSingleNode) {
        return {
            ...computedRole,
            errorType: 'NO_OWNER',
        };
    }
    /**
     * Presentational Roles Conflict Resolution
     *
     * @see https://www.w3.org/TR/wai-aria/#conflict_resolution_presentation_none
     * @see https://w3c.github.io/aria/#conflict_resolution_presentation_none
     */
    /**
     * > If the action of exposing the explicit role
     * > causes the accessibility tree to be malformed,
     * > the expected results are undefined.
     *
     * Determines whether the context is valid.
     * ⚠ THE SPECIFICATION HAS AN ISSUE
     * that has not decided whether the context is a parent or an ancestor.
     *
     * @see https://github.com/w3c/aria/issues/1033
     * @see https://github.com/w3c/aria/issues/748
     * @see https://github.com/w3c/aria/pull/1162
     * @see https://github.com/w3c/aria/pull/1213
     *
     * Currently, this process interprets that as A PARENT
     * because it wants to be near to HTML semantics.
     * However, the presentational role behaves transparently
     * according to the sample code in WAI-ARIA specification.
     */
    if (computedRole.role && computedRole.role.requiredContextRole.length > 0) {
        /**
         * An element fragment that serves as the root without a parent element
         * cannot satisfy the "Required Context Role" condition.
         * Therefore, under normal circumstances, the `role` will disappear.
         * However, in this specific case, it will fall back to both explicit
         * and implicit roles. Note that the explicit role takes precedence.
         */
        if (el.parentElement === null) {
            return {
                ...computedRole,
                errorType: 'NO_OWNER',
            };
        }
        const nonPresentationalAncestor = (0, get_non_presentational_ancestor_1.getNonPresentationalAncestor)(el, specs, version);
        if (!nonPresentationalAncestor.role) {
            return {
                el,
                role: null,
                errorType: 'NO_OWNER',
            };
        }
        if (!(0, matches_context_role_1.matchesContextRole)(computedRole.role.requiredContextRole, el, specs, version)) {
            return {
                el,
                role: null,
                errorType: 'INVALID_REQUIRED_CONTEXT_ROLE',
            };
        }
    }
    /**
     * SVG: Including Elements in the Accessibility Tree
     *
     * > Many SVG elements—although rendered to the screen—
     * > do not have an intrinsic semantic meaning. Instead,
     * > they represent components of the visual presentation of the document.
     * > To simplify the accessible representation of the document,
     * > these purely presentational elements should normally be omitted
     * > from the accessibility tree, unless the author explicitly provides semantic content.
     * >
     * > However, any rendered SVG element may have semantic meaning.
     * > Authors indicate the significance of the element
     * > by including alternative text content or WAI-ARIA attributes.
     * > This section defines the rules for including normally-omitted elements
     * > in the accessibility tree.
     * >
     * > The following graphical and container elements
     * > in the SVG namespace SHOULD NOT be included in the accessibility tree,
     * > except as described in this section:
     * >
     * > - shape elements (circle, ellipse, line, path, polygon, polyline, rect)
     * > - the use element
     * > - the grouping (g) element
     * > - the image element
     * > - the mesh element
     * > - text formatting elements (textPath, tspan)
     * > - the foreignObject element
     *
     * @see https://www.w3.org/TR/svg-aam-1.0/#include_elements
     */
    if (
    // It doesn't been specified a valid explicit role.
    (explicitRole.role === null || explicitRole.errorType != null) &&
        // It is an SVG element.
        el.namespaceURI === 'http://www.w3.org/2000/svg') {
        const accname = (0, accname_computation_1.getAccname)(el).trim() ||
            ((_b = (_a = Array.from(el.children)
                .find(child => ['title', 'desc'].includes(child.localName))) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim());
        if (!accname) {
            return {
                el,
                role: null,
            };
        }
    }
    if (computedRole.role && !(0, is_presentational_1.isPresentational)(computedRole.role.name)) {
        return computedRole;
    }
    /**
     * > If an element is focusable,
     * > user agents MUST ignore the presentation/none role
     * > and expose the element with its implicit role,
     * > in order to ensure that the element is operable.
     *
     * With the issue: What does focusable or otherwise interactive mean](https://github.com/w3c/aria/issues/1192)
     *
     * - Focus: https://html.spec.whatwg.org/multipage/interaction.html#focus
     * - Interactive content: https://html.spec.whatwg.org/multipage/dom.html#interactive-content
     */
    if (
    /**
     * If interactive element
     *
     * 1. It may be focusable
     *
     * THIS CONDITION IS ALMOST MEANINGLESS.
     * Because it has already been determined that
     * the interactive elements can not specify the presentational role
     * in the previous processing that computes the permitted role (`getExplicitRole`).
     */
    (0, may_be_focusable_1.mayBeFocusable)(el, specs) &&
        /**
         * 2. No disabled
         */
        !someAncestors(el, p => isEnabledAttr(p, specs, 'disabled')) &&
        /**
         * 3. No inert
         */
        !someAncestors(el, p => isEnabledAttr(p, specs, 'inert')) &&
        /**
         * 4. No hidden
         */
        !someAncestors(el, p => isEnabledAttr(p, specs, 'hidden'))) {
        return {
            ...implicitRole,
            errorType: 'INTERACTIVE_ELEMENT_MUST_NOT_BE_PRESENTATIONAL',
        };
    }
    /**
     * > If a required owned element has an explicit non-presentational role,
     * > user agents MUST ignore an inherited presentational role
     * > and expose the element with its explicit role.
     *
     * In other words,
     * if the element has `role=presentation` and
     * the role of the parent element has a required owned element,
     * `role=presentation` is to be ignored absolutely.
     */
    if (explicitRole.role) {
        const nonPresentationalAncestor = (0, get_non_presentational_ancestor_1.getNonPresentationalAncestor)(el, specs, version);
        if (nonPresentationalAncestor.role && ((_c = nonPresentationalAncestor.role) === null || _c === void 0 ? void 0 : _c.requiredOwnedElements.length) > 0) {
            if (nonPresentationalAncestor.role.requiredOwnedElements.some(expected => {
                // const ancestor = nonPresentationalAncestor.el;
                // const ancestorImplicitRole = getImplicitRole(specs, ancestor, version);
                // console.log({ nonPresentationalAncestor, ancestorImplicitRole });
                return (0, has_required_owned_elements_1.isRequiredOwnedElement)(implicitRole.el, implicitRole.role, expected, specs, version);
            })) {
                return {
                    ...implicitRole,
                    errorType: 'REQUIRED_OWNED_ELEMENT_MUST_NOT_BE_PRESENTATIONAL',
                };
            }
        }
    }
    /**
     * > If an element has global WAI-ARIA states or properties,
     * > user agents MUST ignore the presentation role
     * > and instead expose the element's implicit role.
     * > However, if an element has only non-global,
     * > role-specific WAI-ARIA states or properties,
     * > the element MUST NOT be exposed
     * > unless the presentational role is inherited
     * > and an explicit non-presentational role is applied.
     */
    const { props } = (0, aria_specs_1.ariaSpecs)(specs, version);
    for (const attr of Array.from(el.attributes)) {
        if ((_d = props.find(p => p.name === attr.name)) === null || _d === void 0 ? void 0 : _d.isGlobal) {
            return {
                ...implicitRole,
                errorType: 'GLOBAL_PROP_MUST_NOT_BE_PRESENTATIONAL',
            };
        }
    }
    return computedRole;
}
exports.getComputedRole = getComputedRole;
/**
 * The attribute is available in its owner element,
 * it has the attribute.
 */
function isEnabledAttr(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, specs, attrName) {
    const attrs = (0, get_attr_specs_1.getAttrSpecs)(el, specs);
    const attr = attrs === null || attrs === void 0 ? void 0 : attrs.find(attr => attr.name === attrName);
    return !!attr && el.hasAttribute(attrName);
}
/**
 * Determines whether some ancestors match the condition that the specified callback function.
 */
function someAncestors(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, predicate) {
    const list = [];
    let current = el;
    while (current) {
        list.push(current);
        current = current.parentElement;
    }
    return list.some(predicate);
}
