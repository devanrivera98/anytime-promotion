"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComputedAriaProps = void 0;
const aria_specs_1 = require("../specs/aria-specs");
const get_computed_role_1 = require("./get-computed-role");
function getComputedAriaProps(specs, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, version) {
    const ariaSpecs = (0, aria_specs_1.ariaSpecs)(specs, version);
    const { role } = (0, get_computed_role_1.getComputedRole)(specs, el, version);
    if (!role) {
        return {};
    }
    const props = {};
    role.ownedProperties.forEach(ownedProp => {
        var _a;
        const spec = ariaSpecs.props.find(propSpec => propSpec.name === ownedProp.name);
        if (!spec) {
            return;
        }
        if (el.hasAttribute(spec.name)) {
            const attrValue = el.getAttribute(spec.name);
            if (attrValue && isValidAriaValue(spec, role.name, attrValue, spec.enum)) {
                props[ownedProp.name] = {
                    name: ownedProp.name,
                    value: attrValue,
                    deprecated: !!spec.deprecated,
                    required: !!ownedProp.required,
                    from: 'aria-attr',
                };
                return;
            }
        }
        const equivalentHtmlAttr = (_a = spec.equivalentHtmlAttrs) === null || _a === void 0 ? void 0 : _a[0];
        if (equivalentHtmlAttr && el.hasAttribute(equivalentHtmlAttr.htmlAttrName)) {
            const value = equivalentHtmlAttr.value === null
                ? el.getAttribute(equivalentHtmlAttr.htmlAttrName)
                : equivalentHtmlAttr.value;
            if (value != null) {
                props[ownedProp.name] = {
                    name: ownedProp.name,
                    value,
                    deprecated: !!spec.deprecated,
                    required: !!ownedProp.required,
                    from: 'html-attr',
                };
                return;
            }
        }
        let defaultValue = spec.defaultValue;
        /**
         * @see https://www.w3.org/TR/html-aria/#el-h1-h6
         */
        if (ownedProp.name === 'aria-level' && /^H[1-6]$/.test(el.nodeName)) {
            defaultValue = el.nodeName.replace('H', '');
        }
        props[ownedProp.name] = {
            name: ownedProp.name,
            value: defaultValue,
            deprecated: !!spec.deprecated,
            required: !!ownedProp.required,
            from: 'default',
        };
    });
    return props;
}
exports.getComputedAriaProps = getComputedAriaProps;
function isValidAriaValue(spec, role, value, enumList) {
    let type = spec.value;
    if (spec.conditionalValue) {
        for (const cond of spec.conditionalValue) {
            if (cond.role.includes(role)) {
                type = cond.value;
            }
        }
    }
    value = (value !== null && value !== void 0 ? value : '').trim();
    switch (type) {
        case 'string': {
            return true;
        }
        case 'ID reference':
        case 'ID reference list':
        case 'URI': {
            return !!value;
        }
        case 'integer':
        case 'number': {
            return !isNaN(parseFloat(value));
        }
        case 'token':
        case 'token list': {
            if (enumList.length === 0) {
                throw new Error('Need an enum list in token and token list types');
            }
            return enumList.includes(value.toLowerCase());
        }
        case 'tristate': {
            return ['true', 'false', 'mixed'].includes(value.toLowerCase());
        }
        case 'true/false': {
            return ['true', 'false'].includes(value.toLowerCase());
        }
        case 'true/false/undefined': {
            return ['true', 'false', 'undefined'].includes(value.toLowerCase());
        }
    }
}
