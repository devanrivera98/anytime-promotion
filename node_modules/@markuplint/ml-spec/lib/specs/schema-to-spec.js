"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaToSpec = void 0;
const merge_array_1 = require("../utils/merge-array");
/**
 * Merging HTML-spec schema and extended spec schemas
 *
 * Ex: `@markuplint/html-spec` + `{ specs: { "\\.vue$": "@markuplint/vue-spec" } }` in configure files.
 *
 * @param schemas `MLDocument.schemas`
 */
function schemaToSpec(schemas) {
    var _a, _b, _c, _d, _e;
    const [main, ...extendedSpecs] = schemas;
    const result = { ...main };
    for (const extendedSpec of extendedSpecs) {
        if (extendedSpec.cites) {
            result.cites = [...result.cites, ...extendedSpec.cites];
        }
        if (extendedSpec.def) {
            const def = { ...result.def };
            if ((_a = extendedSpec.def['#globalAttrs']) === null || _a === void 0 ? void 0 : _a['#extends']) {
                const gAttrs = { ...def['#globalAttrs'] };
                gAttrs['#HTMLGlobalAttrs'] = {
                    ...((_c = (_b = def['#globalAttrs']) === null || _b === void 0 ? void 0 : _b['#HTMLGlobalAttrs']) !== null && _c !== void 0 ? _c : {}),
                    ...((_e = (_d = extendedSpec.def['#globalAttrs']) === null || _d === void 0 ? void 0 : _d['#extends']) !== null && _e !== void 0 ? _e : {}),
                };
                def['#globalAttrs'] = gAttrs;
            }
            if (extendedSpec.def['#aria']) {
                def['#aria'] = {
                    '1.1': {
                        roles: (0, merge_array_1.mergeArray)(def['#aria']['1.1'].roles, extendedSpec.def['#aria']['1.1'].roles),
                        props: (0, merge_array_1.mergeArray)(def['#aria']['1.1'].props, extendedSpec.def['#aria']['1.1'].props),
                        graphicsRoles: (0, merge_array_1.mergeArray)(def['#aria']['1.1'].graphicsRoles, extendedSpec.def['#aria']['1.1'].graphicsRoles),
                    },
                    '1.2': {
                        roles: (0, merge_array_1.mergeArray)(def['#aria']['1.2'].roles, extendedSpec.def['#aria']['1.2'].roles),
                        props: (0, merge_array_1.mergeArray)(def['#aria']['1.2'].props, extendedSpec.def['#aria']['1.2'].props),
                        graphicsRoles: (0, merge_array_1.mergeArray)(def['#aria']['1.2'].graphicsRoles, extendedSpec.def['#aria']['1.2'].graphicsRoles),
                    },
                    '1.3': {
                        roles: (0, merge_array_1.mergeArray)(def['#aria']['1.3'].roles, extendedSpec.def['#aria']['1.3'].roles),
                        props: (0, merge_array_1.mergeArray)(def['#aria']['1.3'].props, extendedSpec.def['#aria']['1.3'].props),
                        graphicsRoles: (0, merge_array_1.mergeArray)(def['#aria']['1.3'].graphicsRoles, extendedSpec.def['#aria']['1.3'].graphicsRoles),
                    },
                };
            }
            if (extendedSpec.def['#contentModels']) {
                const models = { ...def['#contentModels'] };
                const keys = new Set([
                    ...Object.keys(def['#contentModels']),
                    ...Object.keys(extendedSpec.def['#contentModels']),
                ]);
                for (const modelName of keys) {
                    const mainModel = def['#contentModels'][modelName];
                    const exModel = extendedSpec.def['#contentModels'][modelName];
                    models[modelName] = [...(mainModel !== null && mainModel !== void 0 ? mainModel : []), ...(exModel !== null && exModel !== void 0 ? exModel : [])];
                }
                def['#contentModels'] = models;
            }
            result.def = def;
        }
        if (extendedSpec.specs) {
            const exSpecs = extendedSpec.specs.slice();
            const specs = [];
            for (const elSpec of result.specs) {
                const tagName = elSpec.name.toLowerCase();
                const index = exSpecs.findIndex(spec => spec.name.toLowerCase() === tagName);
                if (index === -1) {
                    specs.push(elSpec);
                    continue;
                }
                const exSpec = exSpecs.splice(index, 1)[0];
                specs.push({
                    ...elSpec,
                    ...exSpec,
                    globalAttrs: {
                        ...elSpec.globalAttrs,
                        ...exSpec === null || exSpec === void 0 ? void 0 : exSpec.globalAttrs,
                    },
                    attributes: mergeAttrSpec(elSpec.attributes, exSpec === null || exSpec === void 0 ? void 0 : exSpec.attributes),
                    categories: (0, merge_array_1.mergeArray)(elSpec.categories, exSpec === null || exSpec === void 0 ? void 0 : exSpec.categories),
                });
            }
            result.specs = specs;
        }
    }
    return result;
}
exports.schemaToSpec = schemaToSpec;
function mergeAttrSpec(std, ex = {}) {
    const result = {};
    const keys = Array.from(new Set([...Object.keys(std), ...Object.keys(ex)]));
    for (const key of keys) {
        const _std = std[key];
        const _ex = ex[key];
        result[key] = {
            ..._std,
            ..._ex,
        };
    }
    return result;
}
