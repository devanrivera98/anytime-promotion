"use strict";
var _Selector_ruleset, _Ruleset_selectorGroup, _StructuredSelector_edge, _StructuredSelector_selector, _SelectorTarget_combinedFrom, _SelectorTarget_extended, _SelectorTarget_isAdded;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Selector = void 0;
const tslib_1 = require("tslib");
const ml_spec_1 = require("@markuplint/ml-spec");
const postcss_selector_parser_1 = tslib_1.__importStar(require("postcss-selector-parser"));
const compare_specificity_1 = require("./compare-specificity");
const debug_1 = require("./debug");
const invalid_selector_error_1 = require("./invalid-selector-error");
const is_1 = require("./is");
const selLog = debug_1.log.extend('selector');
const resLog = debug_1.log.extend('result');
class Selector {
    constructor(selector, extended = {}) {
        _Selector_ruleset.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _Selector_ruleset, Ruleset.parse(selector, extended), "f");
    }
    match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope) {
        scope = (0, is_1.isElement)(el) ? el : null;
        const results = this.search(el, scope);
        for (const result of results) {
            if (result.matched) {
                return result.specificity;
            }
        }
        return false;
    }
    search(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope) {
        scope = (0, is_1.isElement)(el) ? el : null;
        return tslib_1.__classPrivateFieldGet(this, _Selector_ruleset, "f").match(el, scope);
    }
}
exports.Selector = Selector;
_Selector_ruleset = new WeakMap();
class Ruleset {
    static parse(selector, extended) {
        const selectors = [];
        try {
            (0, postcss_selector_parser_1.default)(root => {
                selectors.push(...root.nodes);
            }).processSync(selector);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new invalid_selector_error_1.InvalidSelectorError(selector);
            }
            throw e;
        }
        return new Ruleset(selectors, extended, 0);
    }
    constructor(selectors, extended, depth) {
        var _a, _b, _c;
        _Ruleset_selectorGroup.set(this, []);
        tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f").push(...selectors.map(selector => new StructuredSelector(selector, depth, extended)));
        const head = tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f")[0];
        this.headCombinator = (_a = head === null || head === void 0 ? void 0 : head.headCombinator) !== null && _a !== void 0 ? _a : null;
        if (this.headCombinator) {
            if (depth <= 0) {
                if ((_b = tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f")[0]) === null || _b === void 0 ? void 0 : _b.selector) {
                    throw new invalid_selector_error_1.InvalidSelectorError((_c = tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f")[0]) === null || _c === void 0 ? void 0 : _c.selector);
                }
                throw new Error('Combinated selector depth is not expected');
            }
        }
    }
    match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope) {
        (0, debug_1.log)('<%s> (%s)', (0, is_1.isElement)(el) ? el.localName : el.nodeName, scope ? ((0, is_1.isElement)(scope) ? scope.localName : scope.nodeName) : null);
        return tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f").map(selector => {
            selLog('"%s"', selector.selector);
            const res = selector.match(el, scope);
            resLog('%s "%s" => %o', (0, is_1.isElement)(el) ? el.localName : el.nodeName, selector.selector, res);
            return res;
        });
    }
}
_Ruleset_selectorGroup = new WeakMap();
class StructuredSelector {
    constructor(selector, depth, extended) {
        var _a, _b;
        _StructuredSelector_edge.set(this, void 0);
        _StructuredSelector_selector.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _StructuredSelector_selector, selector, "f");
        tslib_1.__classPrivateFieldSet(this, _StructuredSelector_edge, new SelectorTarget(extended, depth), "f");
        this.headCombinator =
            ((_a = tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes[0]) === null || _a === void 0 ? void 0 : _a.type) === 'combinator' ? (_b = tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes[0].value) !== null && _b !== void 0 ? _b : null : null;
        const nodes = tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes.slice();
        if (0 < depth && this.headCombinator) {
            nodes.unshift((0, postcss_selector_parser_1.pseudo)({ value: ':scope' }));
        }
        nodes.forEach(node => {
            switch (node.type) {
                case 'combinator': {
                    const combinedTarget = new SelectorTarget(extended, depth);
                    combinedTarget.from(tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f"), node);
                    tslib_1.__classPrivateFieldSet(this, _StructuredSelector_edge, combinedTarget, "f");
                    break;
                }
                case 'root':
                case 'string': {
                    throw new Error(`Unsupported selector: ${selector.toString()}`);
                }
                case 'nesting': {
                    throw new Error(`Unsupported nested selector: ${selector.toString()}`);
                }
                case 'comment': {
                    throw new Error(`Unsupported comment in selector: ${selector.toString()}`);
                }
                default: {
                    tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f").add(node);
                }
            }
        });
    }
    get selector() {
        return tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes.join('');
    }
    match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope) {
        return tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f").match(el, scope, 0);
    }
}
_StructuredSelector_edge = new WeakMap(), _StructuredSelector_selector = new WeakMap();
class SelectorTarget {
    constructor(extended, depth) {
        this.attr = [];
        this.class = [];
        _SelectorTarget_combinedFrom.set(this, null);
        _SelectorTarget_extended.set(this, void 0);
        this.id = [];
        _SelectorTarget_isAdded.set(this, false);
        this.pseudo = [];
        this.tag = null;
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_extended, extended, "f");
        this.depth = depth;
    }
    add(selector) {
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_isAdded, true, "f");
        switch (selector.type) {
            case 'tag':
            case 'universal': {
                this.tag = selector;
                break;
            }
            case 'id': {
                this.id.push(selector);
                break;
            }
            case 'class': {
                this.class.push(selector);
                break;
            }
            case 'attribute': {
                this.attr.push(selector);
                break;
            }
            case 'pseudo': {
                this.pseudo.push(selector);
                break;
            }
        }
    }
    from(target, combinator) {
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_combinedFrom, { target, combinator }, "f");
    }
    match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope, count) {
        var _a, _b, _c;
        const result = this._match(el, scope, count);
        if (selLog.enabled) {
            const nodeName = el.nodeName;
            const selector = (_b = (_a = tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f")) === null || _a === void 0 ? void 0 : _a.target.toString()) !== null && _b !== void 0 ? _b : this.toString();
            const combinator = result.combinator ? ` ${result.combinator}` : '';
            selLog('The %s element by "%s" => %s (%d)', nodeName, `${selector}${combinator}`, result.matched, count);
            if (selector === ':scope') {
                selLog(`† Scope is the ${(_c = scope === null || scope === void 0 ? void 0 : scope.nodeName) !== null && _c !== void 0 ? _c : null}`);
            }
        }
        delete result.combinator;
        return result;
    }
    toString() {
        var _a, _b;
        return [
            (_b = (_a = this.tag) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
            this.id.map(id => `#${id.value}`).join(''),
            this.class.map(c => `.${c.value}`).join(''),
            this.attr.map(attr => `[${attr.toString()}]`).join(''),
            this.pseudo.map(pseudo => pseudo.value).join(''),
        ].join('');
    }
    _match(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope, count) {
        const unitCheck = this._matchWithoutCombineChecking(el, scope);
        if (!unitCheck.matched) {
            return unitCheck;
        }
        if (!tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f")) {
            return unitCheck;
        }
        if (!(0, is_1.isNonDocumentTypeChildNode)(el)) {
            return unitCheck;
        }
        const { target, combinator } = tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f");
        switch (combinator.value) {
            // Descendant combinator
            case ' ': {
                const matchedNodes = [];
                const has = [];
                const not = [];
                let ancestor = el.parentElement;
                let specificity = undefined;
                while (ancestor) {
                    const res = target.match(ancestor, scope, count + 1);
                    if (!specificity) {
                        specificity = [
                            unitCheck.specificity[0] + res.specificity[0],
                            unitCheck.specificity[1] + res.specificity[1],
                            unitCheck.specificity[2] + res.specificity[2],
                        ];
                    }
                    if (res.matched) {
                        matchedNodes.push(...res.nodes);
                        has.push(...res.has);
                    }
                    else {
                        if (res.not) {
                            not.push(...res.not);
                        }
                    }
                    ancestor = ancestor.parentElement;
                }
                if (!specificity) {
                    const res = target.match(el, scope, count + 1);
                    specificity = [
                        unitCheck.specificity[0] + res.specificity[0],
                        unitCheck.specificity[1] + res.specificity[1],
                        unitCheck.specificity[2] + res.specificity[2],
                    ];
                }
                if (matchedNodes.length > 0) {
                    return {
                        combinator: '␣',
                        specificity,
                        matched: true,
                        nodes: matchedNodes,
                        has,
                    };
                }
                return {
                    combinator: '␣',
                    specificity,
                    matched: false,
                    not,
                };
            }
            // Child combinator
            case '>': {
                const matchedNodes = [];
                const has = [];
                const not = [];
                const specificity = [...unitCheck.specificity];
                const parentNode = el.parentElement;
                if (parentNode) {
                    const res = target.match(parentNode, scope, count + 1);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    if (res.matched) {
                        matchedNodes.push(...res.nodes);
                        has.push(...res.has);
                    }
                    else {
                        if (res.not) {
                            not.push(...res.not);
                        }
                    }
                }
                else {
                    const res = target.match(el, scope, count + 1);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                }
                if (matchedNodes.length > 0) {
                    return {
                        combinator: '>',
                        specificity,
                        matched: true,
                        nodes: matchedNodes,
                        has,
                    };
                }
                return {
                    combinator: '>',
                    specificity,
                    matched: false,
                    not,
                };
            }
            // Next-sibling combinator
            case '+': {
                const matchedNodes = [];
                const has = [];
                const not = [];
                const specificity = [...unitCheck.specificity];
                if (el.previousElementSibling) {
                    const res = target.match(el.previousElementSibling, scope, count + 1);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    if (res.matched) {
                        matchedNodes.push(...res.nodes);
                        has.push(...res.has);
                    }
                    else {
                        if (res.not) {
                            not.push(...res.not);
                        }
                    }
                }
                else {
                    const res = target.match(el, scope, count + 1);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                }
                if (matchedNodes.length > 0) {
                    return {
                        combinator: '+',
                        specificity,
                        matched: true,
                        nodes: matchedNodes,
                        has,
                    };
                }
                return {
                    combinator: '+',
                    specificity,
                    matched: false,
                    not,
                };
            }
            // Subsequent-sibling combinator
            case '~': {
                const matchedNodes = [];
                const has = [];
                const not = [];
                let prev = el.previousElementSibling;
                let specificity = undefined;
                while (prev) {
                    const res = target.match(prev, scope, count + 1);
                    if (!specificity) {
                        specificity = [
                            unitCheck.specificity[0] + res.specificity[0],
                            unitCheck.specificity[1] + res.specificity[1],
                            unitCheck.specificity[2] + res.specificity[2],
                        ];
                    }
                    if (res.matched) {
                        matchedNodes.push(...res.nodes);
                        has.push(...res.has);
                    }
                    else {
                        if (res.not) {
                            not.push(...res.not);
                        }
                    }
                    prev = prev.previousElementSibling;
                }
                if (!specificity) {
                    const res = target.match(el, scope, count + 1);
                    specificity = [
                        unitCheck.specificity[0] + res.specificity[0],
                        unitCheck.specificity[1] + res.specificity[1],
                        unitCheck.specificity[2] + res.specificity[2],
                    ];
                }
                if (matchedNodes.length > 0) {
                    return {
                        combinator: '~',
                        specificity,
                        matched: true,
                        nodes: matchedNodes,
                        has,
                    };
                }
                return {
                    combinator: '~',
                    specificity,
                    matched: false,
                    not,
                };
            }
            // Column combinator
            case '||': {
                throw new Error('Unsupported column combinator yet. If you want it, please request it as the issue (https://github.com/markuplint/markuplint/issues/new).');
            }
            default: {
                throw new Error(`Unsupported ${tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinedFrom, "f").combinator.value} combinator in selector`);
            }
        }
    }
    _matchWithoutCombineChecking(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    el, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    scope) {
        var _a;
        const specificity = [0, 0, 0];
        if (!(0, is_1.isElement)(el)) {
            return {
                specificity,
                matched: false,
            };
        }
        const has = [];
        const not = [];
        // @ts-ignore
        if (this.tag && this.tag._namespace) {
            // @ts-ignore
            const namespace = `${this.tag._namespace}`.toLowerCase();
            switch (namespace) {
                case '*':
                case 'true': {
                    break;
                }
                case 'svg': {
                    if (el.namespaceURI !== 'http://www.w3.org/2000/svg') {
                        return {
                            specificity,
                            matched: false,
                        };
                    }
                    break;
                }
                default: {
                    throw new invalid_selector_error_1.InvalidSelectorError(`The ${namespace} namespace is not supported`);
                }
            }
        }
        let matched = true;
        if (!tslib_1.__classPrivateFieldGet(this, _SelectorTarget_isAdded, "f") && !isScope(el, scope)) {
            matched = false;
        }
        if (!this.id.every(id => id.value === el.id)) {
            matched = false;
        }
        specificity[0] += this.id.length;
        if (!this.class.every(className => el.classList.contains(className.value))) {
            matched = false;
        }
        specificity[1] += this.class.length;
        if (!this.attr.every(attr => attrMatch(attr, el))) {
            matched = false;
        }
        specificity[1] += this.attr.length;
        for (const pseudo of this.pseudo) {
            const pseudoRes = pseudoMatch(pseudo, el, scope, tslib_1.__classPrivateFieldGet(this, _SelectorTarget_extended, "f"), this.depth);
            specificity[0] += pseudoRes.specificity[0];
            specificity[1] += pseudoRes.specificity[1];
            specificity[2] += pseudoRes.specificity[2];
            if (pseudoRes.matched) {
                has.push(...pseudoRes.has);
            }
            else {
                not.push(...((_a = pseudoRes.not) !== null && _a !== void 0 ? _a : []));
                matched = false;
            }
        }
        if (this.tag && this.tag.type === 'tag') {
            specificity[2] += 1;
            let a = this.tag.value;
            let b = el.localName;
            if ((0, is_1.isPureHTMLElement)(el)) {
                a = a.toLowerCase();
                b = b.toLowerCase();
            }
            if (a !== b) {
                matched = false;
            }
        }
        if (matched) {
            return {
                specificity,
                matched,
                nodes: [el],
                has,
            };
        }
        return {
            specificity,
            matched,
            not,
        };
    }
}
_SelectorTarget_combinedFrom = new WeakMap(), _SelectorTarget_extended = new WeakMap(), _SelectorTarget_isAdded = new WeakMap();
function attrMatch(attr, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el) {
    return Array.from(el.attributes).some(attrOfEl => {
        if (attr.attribute !== attrOfEl.localName) {
            return false;
        }
        if (attr.namespace != null && attr.namespace !== true && attr.namespace !== '*') {
            const ns = (0, ml_spec_1.resolveNamespace)(attrOfEl.localName, attrOfEl.namespaceURI);
            if (attr.namespace !== ns.namespace) {
                return false;
            }
        }
        if (attr.value != null) {
            let value = attr.value;
            let valueOfEl = attrOfEl.value;
            if (attr.insensitive) {
                value = value.toLowerCase();
                valueOfEl = valueOfEl.toLowerCase();
            }
            switch (attr.operator) {
                case '=': {
                    if (value !== valueOfEl) {
                        return false;
                    }
                    break;
                }
                case '~=': {
                    if (!valueOfEl.split(/\s+/).includes(value)) {
                        return false;
                    }
                    break;
                }
                case '|=': {
                    if (!new RegExp(`^${value}(?:$|-)`).test(valueOfEl)) {
                        return false;
                    }
                    break;
                }
                case '*=': {
                    if (!valueOfEl.includes(value)) {
                        return false;
                    }
                    break;
                }
                case '^=': {
                    if (valueOfEl.indexOf(value) !== 0) {
                        return false;
                    }
                    break;
                }
                case '$=': {
                    if (valueOfEl.lastIndexOf(value) !== valueOfEl.length - value.length) {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    });
}
function pseudoMatch(pseudo, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
scope, extended, depth) {
    switch (pseudo.value) {
        //
        /**
         * Below, markuplint Specific Selector
         */
        case ':closest': {
            const ruleset = new Ruleset(pseudo.nodes, extended, depth + 1);
            const specificity = getSpecificity(ruleset.match(el, scope));
            let parent = el.parentElement;
            while (parent) {
                const matched = ruleset.match(parent, scope).filter((r) => r.matched);
                if (matched.length > 0) {
                    return {
                        specificity,
                        matched: true,
                        nodes: [el],
                        has: matched,
                    };
                }
                parent = parent.parentElement;
            }
            return {
                specificity,
                matched: false,
            };
        }
        /**
         * Below, Selector Level 4
         */
        case ':not': {
            const ruleset = new Ruleset(pseudo.nodes, extended, depth + 1);
            const resList = ruleset.match(el, scope);
            const specificity = getSpecificity(resList);
            const not = resList.filter((r) => r.matched);
            if (not.length === 0) {
                return {
                    specificity,
                    matched: true,
                    nodes: [el],
                    has: [],
                };
            }
            return {
                specificity,
                matched: false,
                not,
            };
        }
        case ':is': {
            const ruleset = new Ruleset(pseudo.nodes, extended, depth + 1);
            const resList = ruleset.match(el, scope);
            const specificity = getSpecificity(resList);
            const matched = resList.filter((r) => r.matched);
            return {
                specificity,
                matched: matched.length > 0,
                nodes: matched.map(m => m.nodes).flat(),
                has: matched.map(m => m.has).flat(),
            };
        }
        case ':has': {
            const ruleset = new Ruleset(pseudo.nodes, extended, depth + 1);
            const specificity = getSpecificity(ruleset.match(el, scope));
            switch (ruleset.headCombinator) {
                case '+':
                case '~': {
                    const has = getSiblings(el)
                        .map(sib => ruleset.match(sib, el).filter((m) => m.matched))
                        .flat();
                    if (has.length > 0) {
                        return {
                            specificity,
                            matched: true,
                            nodes: [el],
                            has,
                        };
                    }
                    return {
                        specificity,
                        matched: false,
                    };
                }
                default: {
                    const has = getDescendants(el)
                        .map(sib => ruleset.match(sib, el).filter((m) => m.matched))
                        .flat();
                    if (has.length > 0) {
                        return {
                            specificity,
                            matched: true,
                            nodes: [el],
                            has,
                        };
                    }
                    return {
                        specificity,
                        matched: false,
                    };
                }
            }
        }
        case ':where': {
            const ruleset = new Ruleset(pseudo.nodes, extended, depth + 1);
            const resList = ruleset.match(el, scope);
            const matched = resList.filter((r) => r.matched);
            return {
                specificity: [0, 0, 0],
                matched: matched.length > 0,
                nodes: matched.map(m => m.nodes).flat(),
                has: matched.map(m => m.has).flat(),
            };
        }
        case ':scope': {
            if (isScope(el, scope)) {
                return {
                    specificity: [0, 1, 0],
                    matched: true,
                    nodes: [el],
                    has: [],
                };
            }
            return {
                specificity: [0, 1, 0],
                matched: false,
            };
        }
        case ':root': {
            if (el.localName === 'html') {
                return {
                    specificity: [0, 1, 0],
                    matched: true,
                    nodes: [el],
                    has: [],
                };
            }
            return {
                specificity: [0, 1, 0],
                matched: false,
            };
        }
        case ':enable':
        case ':disable':
        case ':read-write':
        case ':read-only':
        case ':placeholder-shown':
        case ':default':
        case ':checked':
        case ':indeterminate':
        case ':valid':
        case ':invalid':
        case ':in-range':
        case ':out-of-range':
        case ':required':
        case ':optional':
        case ':blank':
        case ':user-invalid':
        case ':empty':
        case ':nth-child':
        case ':nth-last-child':
        case ':first-child':
        case ':last-child':
        case ':only-child':
        case ':nth-of-type':
        case ':nth-last-of-type':
        case ':first-of-type':
        case ':last-of-type':
        case ':only-of-type':
        case ':nth-last-col':
        case ':nth-col': {
            throw new Error(`Unsupported pseudo ${pseudo.toString()} selector yet. If you want it, please request it as the issue (https://github.com/markuplint/markuplint/issues/new).`);
        }
        case ':dir':
        case ':lang':
        case ':any-link':
        case ':link':
        case ':visited':
        case ':local-link':
        case ':target':
        case ':target-within':
        case ':current':
        case ':past':
        case ':future':
        case ':active':
        case ':hover':
        case ':focus':
        case ':focus-within':
        case ':focus-visible':
        case '::before':
        case '::after':
        default: {
            for (const ext of Object.keys(extended)) {
                if (pseudo.value !== `:${ext}`) {
                    continue;
                }
                const content = pseudo.nodes.map(node => node.toString()).join('');
                const hook = extended[ext];
                if (!hook) {
                    continue;
                }
                const matcher = hook(content);
                return matcher(el);
            }
            throw new Error(`Unsupported pseudo ${pseudo.toString()} selector.`);
        }
    }
}
function isScope(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
scope) {
    var _a;
    return (_a = el === scope) !== null && _a !== void 0 ? _a : el.parentNode === null;
}
function getDescendants(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, includeSelf = false) {
    return [
        ...Array.from(el.children)
            .map(child => getDescendants(child, true))
            .flat(),
        ...(includeSelf ? [el] : []),
    ];
}
function getSiblings(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el) {
    var _a, _b;
    return Array.from((_b = (_a = el.parentElement) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : []);
}
function getSpecificity(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
results) {
    let specificity = undefined;
    for (const result of results) {
        if (specificity) {
            const order = (0, compare_specificity_1.compareSpecificity)(specificity, result.specificity);
            if (order === -1) {
                specificity = result.specificity;
            }
        }
        else {
            specificity = result.specificity;
        }
    }
    if (!specificity) {
        throw new Error('Result is empty');
    }
    return specificity;
}
