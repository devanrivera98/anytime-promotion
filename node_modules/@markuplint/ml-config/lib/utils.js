"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteUndefProp = exports.isRuleConfigValue = exports.cleanOptions = exports.exchangeValueOnRule = exports.provideValue = void 0;
const tslib_1 = require("tslib");
const is_plain_object_1 = require("is-plain-object");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
/**
 * Return undefined if the template doesn't include the variable that is set as a property in data.
 * But return template string without changes if it doesn't have a variable.
 *
 * @param template Mustache template string
 * @param data Captured string for replacement
 */
function provideValue(template, data) {
    var _a;
    const ast = mustache_1.default.parse(template);
    if (ast.length === 1 && ((_a = ast[0]) === null || _a === void 0 ? void 0 : _a[0]) === 'text') {
        // It doesn't have a variable
        return template;
    }
    const noDataResult = mustache_1.default.render(template, {});
    const result = mustache_1.default.render(template, data);
    // Assume variables are empty in the template if it matched.
    if (noDataResult === result) {
        return;
    }
    return result;
}
exports.provideValue = provideValue;
function exchangeValueOnRule(rule, data) {
    if (isRuleConfigValue(rule)) {
        return exchangeValue(rule, data);
    }
    let result = cleanOptions(rule);
    if (result.value != null) {
        result = {
            ...result,
            value: exchangeValue(result.value, data),
        };
    }
    const options = extractOptions(result);
    if (options != null && options !== '' && options !== 0) {
        const newOptions = exchangeOption(options, data);
        result = {
            ...result,
            ...(newOptions == null
                ? undefined
                : {
                    options: newOptions,
                }),
        };
    }
    if (result.reason != null) {
        const exchangedValue = exchangeValue(result.reason, data);
        result = {
            ...result,
            reason: exchangedValue != null ? `${exchangedValue}` : undefined,
        };
    }
    deleteUndefProp(result);
    return result;
}
exports.exchangeValueOnRule = exchangeValueOnRule;
function cleanOptions(rule) {
    const res = {
        severity: rule.severity,
        value: rule.value,
        options: extractOptions(rule),
        reason: rule.reason,
    };
    deleteUndefProp(res);
    return res;
}
exports.cleanOptions = cleanOptions;
function isRuleConfigValue(v) {
    switch (typeof v) {
        case 'string':
        case 'number':
        case 'boolean': {
            return true;
        }
    }
    if (v === null) {
        return true;
    }
    return Array.isArray(v);
}
exports.isRuleConfigValue = isRuleConfigValue;
/**
 *
 * @param obj
 * @returns
 */
function deleteUndefProp(obj) {
    if (!(0, is_plain_object_1.isPlainObject)(obj)) {
        return;
    }
    for (const key in obj) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
}
exports.deleteUndefProp = deleteUndefProp;
/**
 * Return options from `options` or `option`
 *
 * @param rule
 * @returns
 */
function extractOptions(rule) {
    if ('options' in rule && rule.options != null) {
        return rule.options;
    }
    if ('option' in rule && rule.option != null) {
        return rule.option;
    }
}
function exchangeValue(rule, data) {
    if (rule == null) {
        return rule;
    }
    if (typeof rule === 'string') {
        return provideValue(rule, data);
    }
    if (Array.isArray(rule)) {
        const ruleArray = rule
            .map(val => {
            if (typeof val === 'string') {
                return provideValue(val, data);
            }
            return val;
        })
            .filter((item) => item !== undefined);
        return ruleArray.length > 0 ? ruleArray : undefined;
    }
    return rule;
}
function exchangeOption(optionValue, data) {
    if (optionValue == null) {
        return optionValue;
    }
    if (typeof optionValue === 'boolean' || typeof optionValue === 'number') {
        return optionValue;
    }
    if (typeof optionValue === 'string') {
        return provideValue(optionValue, data);
    }
    if (isArray(optionValue)) {
        return optionValue.map(v => exchangeOption(v, data));
    }
    const result = {};
    Object.keys(optionValue).forEach(key => {
        result[key] = exchangeOption(optionValue[key], data);
    });
    return result;
}
/**
 * Array.isArray for ReadonlyArray
 *
 * > Array.isArray type narrows to any[] for ReadonlyArray<T>
 *
 * @see https://github.com/microsoft/TypeScript/issues/17002
 *
 * @param value
 * @returns
 */
function isArray(value) {
    return Array.isArray(value);
}
