"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeRule = exports.mergeConfig = void 0;
const tslib_1 = require("tslib");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const utils_1 = require("./utils");
function mergeConfig(a, b) {
    const config = {
        ...a,
        ...b,
        plugins: concatArray(a.plugins, b.plugins, true, 'name'),
        parser: mergeObject(a.parser, b.parser),
        parserOptions: mergeObject(a.parserOptions, b.parserOptions),
        specs: mergeObject(a.specs, b.specs),
        excludeFiles: concatArray(a.excludeFiles, b.excludeFiles, true),
        rules: mergeRules(
        // TODO: Deep merge
        a.rules, b.rules),
        nodeRules: concatArray(a.nodeRules, b.nodeRules),
        childNodeRules: concatArray(a.childNodeRules, b.childNodeRules),
        overrides: mergeObject(a.overrides, b.overrides),
        // delete all
        extends: undefined,
    };
    (0, utils_1.deleteUndefProp)(config);
    return config;
}
exports.mergeConfig = mergeConfig;
function mergeRule(a, b) {
    var _a, _b, _c;
    const oA = optimizeRule(a);
    const oB = optimizeRule(b);
    // Particular behavior:
    // If the right-side value is false, return false.
    // In short; The `false` makes the rule to be disabled absolutely.
    if (oB === false || (!(0, utils_1.isRuleConfigValue)(oB) && (oB === null || oB === void 0 ? void 0 : oB.value) === false)) {
        return false;
    }
    if (oA === undefined) {
        return oB !== null && oB !== void 0 ? oB : {};
    }
    if (oB === undefined) {
        return oA;
    }
    if ((0, utils_1.isRuleConfigValue)(oB)) {
        if ((0, utils_1.isRuleConfigValue)(oA)) {
            if (Array.isArray(oA) && Array.isArray(oB)) {
                return [...oA, ...oB];
            }
            return oB;
        }
        const value = Array.isArray(oA.value) && Array.isArray(oB) ? [...oA.value, ...oB] : oB;
        const res = (0, utils_1.cleanOptions)({ ...oA, value });
        (0, utils_1.deleteUndefProp)(res);
        return res;
    }
    const severity = (_a = oB.severity) !== null && _a !== void 0 ? _a : (!(0, utils_1.isRuleConfigValue)(oA) ? oA.severity : undefined);
    const value = (_b = oB.value) !== null && _b !== void 0 ? _b : ((0, utils_1.isRuleConfigValue)(oA) ? oA : oA.value);
    const options = mergeObject(!(0, utils_1.isRuleConfigValue)(oA) ? oA.options : undefined, oB.options);
    const reason = (_c = oB.reason) !== null && _c !== void 0 ? _c : (!(0, utils_1.isRuleConfigValue)(oA) ? oA.reason : undefined);
    const res = {
        severity,
        value,
        options,
        reason,
    };
    (0, utils_1.deleteUndefProp)(res);
    return res;
}
exports.mergeRule = mergeRule;
function mergeObject(a, b) {
    if (a == null) {
        return b !== null && b !== void 0 ? b : undefined;
    }
    if (b == null) {
        return a !== null && a !== void 0 ? a : undefined;
    }
    const res = (0, deepmerge_1.default)(a, b);
    (0, utils_1.deleteUndefProp)(res);
    return res;
}
function concatArray(a, b, uniquely = false, comparePropName) {
    const newArray = [];
    function concat(item) {
        if (!uniquely) {
            newArray.push(item);
            return;
        }
        if (newArray.includes(item)) {
            return;
        }
        if (!comparePropName) {
            newArray.push(item);
            return;
        }
        const name = getName(item, comparePropName);
        if (!name) {
            newArray.push(item);
            return;
        }
        const existedIndex = newArray.findIndex(e => getName(e, comparePropName) === name);
        if (existedIndex === -1) {
            newArray.push(item);
            return;
        }
        if (typeof item === 'string') {
            return;
        }
        const existed = newArray[existedIndex];
        const merged = mergeObject(existed, item);
        if (!merged) {
            newArray.push(item);
            return;
        }
        newArray.splice(existedIndex, 1, merged);
    }
    a === null || a === void 0 ? void 0 : a.forEach(concat);
    b === null || b === void 0 ? void 0 : b.forEach(concat);
    return newArray.length === 0 ? undefined : newArray;
}
function getName(item, comparePropName) {
    if (item == null) {
        return null;
    }
    if (typeof item === 'string') {
        return item;
    }
    if (typeof item === 'object' && item && comparePropName in item && typeof item[comparePropName] === 'string') {
        return item[comparePropName];
    }
    return null;
}
function mergeRules(a, b) {
    if (a == null) {
        return b && optimizeRules(b);
    }
    if (b == null) {
        return optimizeRules(a);
    }
    const res = optimizeRules(a);
    for (const [key, rule] of Object.entries(b)) {
        const merged = mergeRule(res[key], rule);
        if (merged != null) {
            res[key] = merged;
        }
    }
    (0, utils_1.deleteUndefProp)(res);
    return Object.freeze(res);
}
function optimizeRules(rules) {
    const res = {};
    for (const [key, rule] of Object.entries(rules)) {
        const _rule = optimizeRule(rule);
        if (_rule != null) {
            res[key] = _rule;
        }
    }
    return res;
}
function optimizeRule(rule) {
    if (rule === undefined) {
        return;
    }
    if ((0, utils_1.isRuleConfigValue)(rule)) {
        return rule;
    }
    return (0, utils_1.cleanOptions)(rule);
}
