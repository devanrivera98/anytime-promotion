"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssSyntaxMatch = void 0;
const css_tree_1 = require("css-tree");
const debug_1 = require("./debug");
const defs_1 = require("./defs");
const match_result_1 = require("./match-result");
const MIMIC_TAG_L = 'mimiccases---';
const MIMIC_TAG_R = '---mimiccases';
const MIMIC_LENGTH = (MIMIC_TAG_L + MIMIC_TAG_R).length;
function cssSyntaxMatch(value, type) {
    var _a;
    (0, debug_1.log)('Search CSS Syntax: "%s"', type);
    const origin = value;
    let defName;
    const typesExtended = {};
    const typesCheckers = {};
    let propsExtended;
    let ref = undefined;
    let caseSensitive = false;
    let ebnf = null;
    if (typeof type === 'string') {
        defName = type;
        propsExtended = {};
    }
    else {
        defName = type.syntax.apply;
        ebnf = (_a = type.syntax.ebnf) !== null && _a !== void 0 ? _a : null;
        if (ebnf) {
            // Work in progress
            return (0, match_result_1.matched)();
        }
        const types = {
            ...defs_1.tokenizers,
            ...type.syntax.def,
        };
        Object.keys(types).forEach(key => {
            const valueOrChecker = types[key];
            if (typeof valueOrChecker === 'string') {
                typesExtended[key] = valueOrChecker;
            }
            else if (valueOrChecker) {
                typesCheckers[key] = valueOrChecker;
            }
        });
        propsExtended = { ...type.syntax.properties };
        if (type.caseSensitive) {
            caseSensitive = true;
            Object.keys(typesExtended).forEach(key => eachMimicCases(key, typesExtended));
            Object.keys(propsExtended).forEach(key => eachMimicCases(key, propsExtended));
            value = mimicCases(value);
        }
        ref = type.ref;
    }
    // @ts-ignore
    const lexer = (0, css_tree_1.fork)({
        types: typesExtended,
        properties: propsExtended,
    }).lexer;
    Object.keys(typesCheckers).forEach(key => {
        const checker = typesCheckers[key];
        // @ts-ignore
        lexer.addType_(key, (token, getNextToken) => checker === null || checker === void 0 ? void 0 : checker(token, getNextToken, cssSyntaxMatch));
    });
    const { isProp, name } = detectName(defName);
    // @ts-ignore
    const matcher = isProp ? lexer.properties[name] : lexer.types[name];
    if (!matcher) {
        (0, debug_1.log)('"%s" CSS syntax not found', defName);
        throw new Error('MARKUPLINT_TYPE_NO_EXIST');
    }
    const refParam = isProp ? 'Property' : 'Type';
    ref = ref !== null && ref !== void 0 ? ref : `https://csstree.github.io/docs/syntax/#${refParam}:${name}`;
    // eslint-disable-next-line no-console
    const _w = console.warn;
    if (debug_1.log.enabled) {
        // eslint-disable-next-line no-console
        console.warn = warn => (0, debug_1.log)('WARNING: %s (by %s => %s)', warn, value, type);
    }
    const result = lexer.match(defName, value);
    (0, debug_1.log)('css-tree/result: %O', result);
    // eslint-disable-next-line no-console
    console.warn = _w;
    if (!result.error) {
        return (0, match_result_1.matched)();
    }
    if (!('css' in result.error)) {
        throw result.error;
    }
    const error = result.error;
    if (caseSensitive) {
        const offset = error.mismatchOffset % MIMIC_LENGTH;
        const diff = error.mismatchOffset - offset;
        error.message = deMimicCases(error.message).replace('-'.repeat(diff), '');
        error.syntax = deMimicCases(error.syntax);
        error.css = deMimicCases(error.css);
        error.mismatchOffset = offset;
        error.column = error.column % MIMIC_LENGTH;
        const mismatchLength = error.mismatchLength - MIMIC_LENGTH;
        error.mismatchLength = mismatchLength < 0 ? error.mismatchLength : mismatchLength;
    }
    (0, debug_1.log)('css-tree/SyntaxMatchError: %O', error);
    return {
        matched: false,
        ref,
        raw: origin.slice(error.mismatchOffset, error.mismatchOffset + error.mismatchLength),
        offset: error.mismatchOffset,
        length: error.mismatchLength,
        line: error.line,
        column: error.column,
        expects: [
            {
                type: 'syntax',
                value: error.syntax,
            },
        ],
        partName: error.mismatchOffset === 0 ? undefined : 'value',
        reason: 'syntax-error',
    };
}
exports.cssSyntaxMatch = cssSyntaxMatch;
function detectName(def) {
    const isProp = def.search("<'") === 0;
    const name = def.replace(/^<'?|'?>$/g, '');
    return {
        isProp,
        name,
    };
}
/**
 *
 * @param key
 * @param obj
 * @modifies obj
 * @returns
 */
function eachMimicCases(key, 
// Mutable
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
obj) {
    const value = obj[key];
    if (!value) {
        return;
    }
    obj[key] = mimicCases(value);
}
function mimicCases(value) {
    return value.replace(/[A-Z]/g, $0 => `${MIMIC_TAG_L}${$0}${MIMIC_TAG_R}`);
}
function deMimicCases(value) {
    return value.replace(new RegExp(`${MIMIC_TAG_L}([A-Z])${MIMIC_TAG_R}`, 'g'), (_, $1) => $1);
}
