"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
class Token {
    static getCol(value, offset) {
        var _a;
        const lines = value.slice(0, offset).split(/\n/g);
        return ((_a = lines[lines.length - 1]) !== null && _a !== void 0 ? _a : '').length + 1;
    }
    static getLine(value, offset) {
        return value.slice(0, offset).split(/\n/g).length;
    }
    static getType(value, separators) {
        var _a, _b;
        if (Token.whitespace.includes((_a = value[0]) !== null && _a !== void 0 ? _a : '')) {
            return Token.WhiteSpace;
        }
        if (separators === null || separators === void 0 ? void 0 : separators.includes((_b = value[0]) !== null && _b !== void 0 ? _b : '')) {
            switch (value[0]) {
                case ',':
                    return Token.Comma;
            }
        }
        return Token.Ident;
    }
    static shiftLocation(token, offset) {
        const shifted = token.offset + offset;
        return {
            offset: shifted,
            line: Token.getLine(token.originalValue, shifted),
            column: Token.getCol(token.originalValue, shifted),
        };
    }
    constructor(value, offset, originalValue, separators) {
        this.type = Token.getType(value, separators);
        this.value = value;
        this.offset = offset;
        this.originalValue = originalValue;
    }
    get length() {
        return this.value.length;
    }
    clone() {
        return new Token(this.value, this.offset, this.originalValue);
    }
    /**
     *
     * @param value The token value or the token type or its list
     */
    includes(value, caseInsensitive) {
        if (Array.isArray(value)) {
            return value.some(v => this.includes(v));
        }
        if (typeof value === 'string') {
            const a = caseInsensitive ? this.value.toLowerCase() : this.value;
            const b = caseInsensitive ? value.toLowerCase() : value;
            return a.includes(b);
        }
        if (value instanceof RegExp) {
            const pattern = new RegExp(value, caseInsensitive ? 'i' : '');
            return pattern.test(this.value);
        }
        return this.type === value;
    }
    /**
     *
     * @param value The token value or the token type or its list
     */
    match(value, caseInsensitive) {
        if (Array.isArray(value)) {
            return value.some(v => this.match(v));
        }
        if (typeof value === 'string') {
            const a = caseInsensitive ? this.value.toLowerCase() : this.value;
            const b = caseInsensitive ? value.toLowerCase() : value;
            return a === b;
        }
        if (value instanceof RegExp) {
            const pattern = new RegExp(value, caseInsensitive ? 'i' : '');
            return pattern.test(this.value);
        }
        return this.type === value;
    }
    toJSON() {
        return {
            type: this.type,
            value: this.value,
            offset: this.offset,
        };
    }
    toNumber() {
        const num = parseFloat(this.value);
        return isNaN(num) ? 0 : num;
    }
    unmatched(options) {
        var _a, _b;
        return {
            ...options,
            matched: false,
            ref: (_a = options === null || options === void 0 ? void 0 : options.ref) !== null && _a !== void 0 ? _a : null,
            raw: this.value,
            offset: this.offset,
            length: this.value.length,
            line: Token.getLine(this.originalValue, this.offset),
            column: Token.getCol(this.originalValue, this.offset),
            reason: (_b = options === null || options === void 0 ? void 0 : options.reason) !== null && _b !== void 0 ? _b : 'syntax-error',
        };
    }
}
exports.Token = Token;
/**
 * @see https://github.com/csstree/csstree/blob/master/lib/tokenizer/types.js
 */
Token.Comma = 18;
Token.Ident = 1;
Token.WhiteSpace = 13;
/**
 * ASCII whitespace is
 * - U+0009 TAB
 * - U+000A LF
 * - U+000C FF
 * - U+000D CR
 * - U+0020 SPACE.
 *
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 */
Token.whitespace = ['\u0009', '\u000A', '\u000C', '\u000D', '\u0020'];
