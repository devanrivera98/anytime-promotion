"use strict";
var _MLDomTokenList_origin, _MLDomTokenList_ownerAttrs, _MLDomTokenList_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLDomTokenList = void 0;
const tslib_1 = require("tslib");
const parser_utils_1 = require("@markuplint/parser-utils");
const unexpected_call_error_1 = tslib_1.__importDefault(require("./unexpected-call-error"));
class MLDomTokenList extends Array {
    constructor(tokens, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    ownerAttrs) {
        const list = tokens
            .split(/\s+/)
            .map(t => t.trim())
            .filter(t => !!t);
        super(...list);
        _MLDomTokenList_origin.set(this, void 0);
        /**
         * In some cases, an author specifies multiple attributes or directives.
         * The reference is not always one.
         */
        _MLDomTokenList_ownerAttrs.set(this, void 0);
        _MLDomTokenList_set.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _MLDomTokenList_origin, tokens, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDomTokenList_ownerAttrs, ownerAttrs, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDomTokenList_set, new Set(list), "f");
    }
    get value() {
        return this.join(' ');
    }
    add(...tokens) {
        for (const token of tokens) {
            if (tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_set, "f").has(token)) {
                continue;
            }
            tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_set, "f").add(token);
            this.push(token);
        }
        tslib_1.__classPrivateFieldSet(this, _MLDomTokenList_origin, tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_origin, "f") + tokens.join(' '), "f");
    }
    /**
     * @implements `@markuplint/ml-core` API: `MLDomTokenList`
     */
    allTokens() {
        let offset = 0;
        const tokens = Array.from(this);
        const locs = [];
        while (tokens.length > 0) {
            const token = tokens.shift();
            if (!token) {
                break;
            }
            const loc = this._pick(token, offset);
            if (!loc) {
                offset = 0;
                continue;
            }
            offset = loc._searchedIndex;
            locs.push({
                raw: loc.raw,
                startOffset: loc.startOffset,
                startLine: loc.startLine,
                startCol: loc.startCol,
                rule: loc.rule,
            });
        }
        return locs;
    }
    contains(token) {
        return tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_set, "f").has(token);
    }
    forEach(callbackfn, thisArg) {
        this.forEach.bind(this)((v, i) => callbackfn(v, i, thisArg !== null && thisArg !== void 0 ? thisArg : this));
    }
    item(index) {
        var _a;
        return (_a = this[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * @implements `@markuplint/ml-core` API: `MLDomTokenList`
     */
    pick(token) {
        const r = this._pick(token);
        if (!r) {
            return null;
        }
        return {
            raw: r.raw,
            startOffset: r.startOffset,
            startLine: r.startLine,
            startCol: r.startCol,
            rule: r.rule,
        };
    }
    remove(...tokens) {
        throw new unexpected_call_error_1.default('Not supported "remove" method');
    }
    replace(token, newToken) {
        throw new unexpected_call_error_1.default('Not supported "replace" method');
    }
    supports(token) {
        throw new unexpected_call_error_1.default('Not supported "supports" method');
    }
    toString() {
        return this.value;
    }
    toggle(token, force) {
        throw new unexpected_call_error_1.default('Not supported "toggle" method');
    }
    _pick(token, _offset = 0) {
        var _a, _b, _c, _d, _e, _f, _g;
        token = (_a = token.trim().split(/\s+/g)[0]) !== null && _a !== void 0 ? _a : '';
        if (!token) {
            return null;
        }
        for (const ownerAttr of tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_ownerAttrs, "f")) {
            if (ownerAttr.isDynamicValue) {
                continue;
            }
            const startOffset = tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_origin, "f").indexOf(token, _offset);
            if (startOffset === -1) {
                continue;
            }
            const startLine = (0, parser_utils_1.getLine)(tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_origin, "f"), startOffset);
            const startCol = (0, parser_utils_1.getCol)(tslib_1.__classPrivateFieldGet(this, _MLDomTokenList_origin, "f"), startOffset);
            return {
                raw: token,
                startOffset: ((_c = (_b = ownerAttr.valueNode) === null || _b === void 0 ? void 0 : _b.startOffset) !== null && _c !== void 0 ? _c : 0) + startOffset,
                startLine: ((_e = (_d = ownerAttr.valueNode) === null || _d === void 0 ? void 0 : _d.startLine) !== null && _e !== void 0 ? _e : 0) + (startLine - 1),
                startCol: ((_g = (_f = ownerAttr.valueNode) === null || _f === void 0 ? void 0 : _f.startCol) !== null && _g !== void 0 ? _g : 0) + (startCol - 1),
                rule: ownerAttr.rule,
                _searchedIndex: startOffset,
            };
        }
        return null;
    }
}
exports.MLDomTokenList = MLDomTokenList;
_MLDomTokenList_origin = new WeakMap(), _MLDomTokenList_ownerAttrs = new WeakMap(), _MLDomTokenList_set = new WeakMap();
