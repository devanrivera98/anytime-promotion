"use strict";
var _MLAttr_localName, _MLAttr_namespaceURI, _MLAttr_potentialName, _MLAttr_potentialValue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLAttr = void 0;
const tslib_1 = require("tslib");
const ml_spec_1 = require("@markuplint/ml-spec");
const token_1 = require("../token/token");
const dom_token_list_1 = require("./dom-token-list");
const node_1 = require("./node");
const unexpected_call_error_1 = tslib_1.__importDefault(require("./unexpected-call-error"));
class MLAttr extends node_1.MLNode {
    constructor(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    astToken, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    ownElement) {
        var _a, _b, _c, _d;
        super(astToken, ownElement.ownerMLDocument);
        this.endQuote = null;
        this.equal = null;
        _MLAttr_localName.set(this, void 0);
        this.nameNode = null;
        _MLAttr_namespaceURI.set(this, void 0);
        _MLAttr_potentialName.set(this, void 0);
        _MLAttr_potentialValue.set(this, void 0);
        this.spacesAfterEqual = null;
        this.spacesBeforeEqual = null;
        this.spacesBeforeName = null;
        this.startQuote = null;
        this.valueNode = null;
        /**
         * Returns the "string" if HTML syntax. Otherwise, returns a type in its syntax.
         *
         * @default "string"
         * @implements `@markuplint/ml-core` API: `MLAttr`
         */
        this.valueType = 'string';
        if (this._astToken.type === 'html-attr') {
            this.spacesBeforeName = new token_1.MLToken(this._astToken.spacesBeforeName);
            this.nameNode = new token_1.MLToken(this._astToken.name);
            this.spacesBeforeEqual = new token_1.MLToken(this._astToken.spacesBeforeEqual);
            this.equal = new token_1.MLToken(this._astToken.equal);
            this.spacesAfterEqual = new token_1.MLToken(this._astToken.spacesAfterEqual);
            this.startQuote = new token_1.MLToken(this._astToken.startQuote);
            this.valueNode = new token_1.MLToken(this._astToken.value);
            this.endQuote = new token_1.MLToken(this._astToken.endQuote);
            this.isDynamicValue = this._astToken.isDynamicValue;
            this.isDirective = this._astToken.isDirective;
            this.candidate = this._astToken.candidate;
            tslib_1.__classPrivateFieldSet(this, _MLAttr_potentialName, (_c = (_a = this._astToken.potentialName) !== null && _a !== void 0 ? _a : (_b = this.nameNode) === null || _b === void 0 ? void 0 : _b.raw) !== null && _c !== void 0 ? _c : '', "f");
            tslib_1.__classPrivateFieldSet(this, _MLAttr_potentialValue, (_d = this._astToken.value.raw) !== null && _d !== void 0 ? _d : '', "f");
        }
        else {
            this.valueType = this._astToken.valueType;
            this.isDuplicatable = this._astToken.isDuplicatable;
            tslib_1.__classPrivateFieldSet(this, _MLAttr_potentialName, this._astToken.potentialName, "f");
            tslib_1.__classPrivateFieldSet(this, _MLAttr_potentialValue, this._astToken.potentialValue, "f");
        }
        const ns = (0, ml_spec_1.resolveNamespace)(tslib_1.__classPrivateFieldGet(this, _MLAttr_potentialName, "f"), ownElement.namespaceURI);
        tslib_1.__classPrivateFieldSet(this, _MLAttr_localName, ns.localName, "f");
        tslib_1.__classPrivateFieldSet(this, _MLAttr_namespaceURI, ns.namespaceURI, "f");
        this.ownerElement = ownElement;
        this.isDuplicatable = this._astToken.isDuplicatable;
    }
    /**
     * **IT THROWS AN ERROR WHEN CALLING THIS.**
     *
     * @unsupported
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#ref-for-dom-attr-localname
     */
    get localName() {
        return tslib_1.__classPrivateFieldGet(this, _MLAttr_localName, "f");
    }
    /**
     *
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#dom-attr-name
     */
    get name() {
        return tslib_1.__classPrivateFieldGet(this, _MLAttr_potentialName, "f");
    }
    /**
     * **IT THROWS AN ERROR WHEN CALLING THIS.**
     *
     * @unsupported
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#ref-for-dom-attr-namespaceuri
     */
    get namespaceURI() {
        return tslib_1.__classPrivateFieldGet(this, _MLAttr_namespaceURI, "f");
    }
    /**
     * Returns a string appropriate for the type of node as `Attr`
     *
     * @see https://dom.spec.whatwg.org/#ref-for-attr%E2%91%A4
     */
    get nodeName() {
        return this.name;
    }
    /**
     * Returns a number appropriate for the type of `Attr`
     */
    get nodeType() {
        return this.ATTRIBUTE_NODE;
    }
    get nodeValue() {
        return this.value;
    }
    /**
     * **IT THROWS AN ERROR WHEN CALLING THIS.**
     *
     * @unsupported
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#ref-for-dom-attr-prefix
     */
    get prefix() {
        throw new unexpected_call_error_1.default('Not supported "prefix" property');
    }
    /**
     * @implements `@markuplint/ml-core` API: `MLAttr`
     */
    get rule() {
        return this.ownerElement.rule;
    }
    /**
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#dom-attr-specified
     */
    get specified() {
        return true;
    }
    /**
     * @implements `@markuplint/ml-core` API: `MLAttr`
     */
    get tokenList() {
        return this.isDynamicValue ? null : new dom_token_list_1.MLDomTokenList(this.value, [this]);
    }
    /**
     * @implements DOM API: `Attr`
     * @see https://dom.spec.whatwg.org/#dom-attr-value
     */
    get value() {
        return tslib_1.__classPrivateFieldGet(this, _MLAttr_potentialValue, "f");
    }
    /**
     * @implements `@markuplint/ml-core` API: `MLAttr`
     */
    toNormalizeString() {
        if (this.nameNode && this.equal && this.startQuote && this.valueNode && this.endQuote) {
            return (this.nameNode.originRaw +
                this.equal.originRaw +
                this.startQuote.originRaw +
                this.valueNode.originRaw +
                this.endQuote.originRaw);
        }
        return this.raw;
    }
}
exports.MLAttr = MLAttr;
_MLAttr_localName = new WeakMap(), _MLAttr_namespaceURI = new WeakMap(), _MLAttr_potentialName = new WeakMap(), _MLAttr_potentialValue = new WeakMap();
