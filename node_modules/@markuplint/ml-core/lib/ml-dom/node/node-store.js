"use strict";
var _NodeStore_store;
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeStore = void 0;
const tslib_1 = require("tslib");
const parser_utils_1 = require("@markuplint/parser-utils");
const debug_1 = require("../../debug");
const nodeStoreLog = debug_1.log.extend('node-store');
const nodeStoreError = nodeStoreLog.extend('error');
class NodeStore {
    constructor() {
        _NodeStore_store.set(this, new Map());
    }
    getNode(astNode) {
        // console.log(`Get: ${astNode.uuid} -> ${astNode.raw.trim()}(${astNode.type})`);
        const node = tslib_1.__classPrivateFieldGet(this, _NodeStore_store, "f").get(astNode.uuid);
        if (!node) {
            nodeStoreError('Ref ID: %s (%s: "%s")', astNode.uuid, astNode.nodeName, astNode.raw);
            nodeStoreError('Map: %O', Array.from(tslib_1.__classPrivateFieldGet(this, _NodeStore_store, "f").entries()).map(([id, node]) => ({
                id,
                name: node.nodeName,
            })));
            throw new parser_utils_1.TargetParserError('Broke mapping nodes.', {
                line: astNode.startLine,
                col: astNode.startCol,
                raw: astNode.raw,
                nodeName: astNode.nodeName,
            });
        }
        return node;
    }
    setNode(astNode, 
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    node) {
        if (node.is(node.DOCUMENT_NODE)) {
            return;
        }
        if (!astNode.uuid) {
            nodeStoreError('UUID is invalid: %s (%s: "%s")', astNode.uuid, astNode.nodeName, astNode.raw);
            nodeStoreError('Invalid node: %O', node);
        }
        nodeStoreLog('Mapped: %s (%s: "%s")', astNode.uuid, astNode.nodeName, astNode.raw.replace(/\n/g, '⏎').replace(/\t/g, '→'));
        tslib_1.__classPrivateFieldGet(this, _NodeStore_store, "f").set(astNode.uuid, node);
    }
}
_NodeStore_store = new WeakMap();
/**
 * `NodeStore` Singleton
 */
exports.nodeStore = new NodeStore();
