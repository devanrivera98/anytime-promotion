"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.countPattern = void 0;
const debug_1 = require("./debug");
const recursive_branch_1 = require("./recursive-branch");
const utils_1 = require("./utils");
const cLog = debug_1.cmLog.extend('countCompereResult');
/**
 * Check count
 *
 * @param pattern
 * @param elements
 * @param specs
 * @param options
 * @param depth
 * @returns
 */
function countPattern(pattern, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
elements, specs, options, depth) {
    const ptLog = debug_1.cmLog.extend(`countPattern#${depth}`);
    const collection = new utils_1.Collection(elements);
    const { model, min, max, repeat, missingType } = (0, utils_1.normalizeModel)(pattern);
    ptLog('Model:\n  RegEx: %s\n  Schema: %o', (0, utils_1.modelLog)(model, repeat), pattern);
    let prevResult = null;
    let barelyResult = null;
    let loopCount = 0;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        loopCount++;
        ptLog('Check#%s: %s', loopCount, collection);
        const result = (0, recursive_branch_1.recursiveBranch)(model, collection.unmatched, specs, options, depth);
        const added = collection.addMatched(result.matched);
        const { matchedCount } = collection;
        if (result.type === 'UNMATCHED_SELECTOR_BUT_MAY_EMPTY') {
            ptLog('MATCHED_ZERO:\n  model: %s\n  max: %s\n  collection: %s\n  matched element: %s', (0, utils_1.modelLog)(model, repeat), max, collection, matchedCount);
            return compereResult({
                type: 'MATCHED_ZERO',
                matched: collection.matched,
                unmatched: collection.unmatched,
                zeroMatch: true,
                query: result.query,
                hint: result.hint,
            }, barelyResult);
        }
        if (max < collection.matchedCount) {
            collection.max(max);
            ptLog('UNEXPECTED_EXTRA_NODE:\n  model: %s\n  max: %s\n  collection: %s\n  matched element: %s', (0, utils_1.modelLog)(model, repeat), max, collection, matchedCount);
            return compereResult({
                type: 'UNEXPECTED_EXTRA_NODE',
                matched: collection.matched,
                unmatched: collection.unmatched,
                zeroMatch: result.zeroMatch,
                query: result.query,
                hint: (0, utils_1.mergeHints)(result.hint, { max }),
            }, barelyResult);
        }
        if (prevResult) {
            if (result.type === 'MISSING_NODE_ONE_OR_MORE' ||
                result.type === 'MISSING_NODE_REQUIRED' ||
                result.type === 'TRANSPARENT_MODEL_DISALLOWS') {
                ptLog('%s(continued): %s; Needs', result.type, collection, result.query);
                return compereResult({
                    type: result.type,
                    matched: collection.matched,
                    unmatched: collection.unmatched,
                    zeroMatch: result.zeroMatch,
                    query: result.query,
                    hint: result.hint,
                }, barelyResult);
            }
            ptLog('%s(continued): %s', prevResult.type, collection);
            return compereResult(prevResult, barelyResult);
        }
        if (added && collection.unmatched.length > 0) {
            if (result.type !== 'MISSING_NODE' && result.type !== 'UNMATCHED_SELECTORS') {
                barelyResult = {
                    type: result.type,
                    matched: collection.matched,
                    unmatched: collection.unmatched,
                    zeroMatch: result.zeroMatch,
                    query: result.query,
                    hint: result.hint,
                };
            }
            ptLog('continue⤴️');
            continue;
        }
        if (collection.matchedCount + (result.zeroMatch ? 1 : 0) < min) {
            const resultType = result.type === 'MISSING_NODE_REQUIRED' ||
                result.type === 'MISSING_NODE_ONE_OR_MORE' ||
                result.type === 'TRANSPARENT_MODEL_DISALLOWS'
                ? result.type
                : missingType !== null && missingType !== void 0 ? missingType : 'MISSING_NODE_REQUIRED';
            ptLog('%s(in %s); Needs %s', resultType, missingType, result.query);
            return compereResult({
                type: resultType,
                matched: collection.matched,
                unmatched: collection.unmatched,
                zeroMatch: result.zeroMatch,
                query: result.query,
                hint: (0, utils_1.mergeHints)(result.hint, {
                    missing: {
                        barelyMatchedElements: collection.matched.length,
                        need: result.query,
                    },
                }),
            }, barelyResult);
        }
        const resultType = collection.matched.length === 0 ? 'MATCHED_ZERO' : 'MATCHED';
        const zeroMatch = result.zeroMatch || min === 0 || resultType === 'MATCHED_ZERO';
        const matchedResult = {
            type: resultType,
            matched: collection.matched,
            unmatched: collection.unmatched,
            zeroMatch,
            query: result.query,
            hint: (0, utils_1.mergeHints)(result.hint, {
                missing: {
                    barelyMatchedElements: collection.matched.length,
                    need: result.query,
                },
            }),
        };
        if (collection.unmatched.length > 0) {
            prevResult = matchedResult;
            ptLog('continue⤴️ (add prev)');
            continue;
        }
        ptLog('%s:\n  model: %s\n  max: %s\n  collection: %s\n  matched element: %s', resultType, (0, utils_1.modelLog)(model, repeat), max, collection, matchedCount);
        if (result.type === 'MISSING_NODE_REQUIRED' ||
            result.type === 'MISSING_NODE_ONE_OR_MORE' ||
            result.type === 'TRANSPARENT_MODEL_DISALLOWS') {
            return compereResult({
                type: result.type,
                matched: collection.matched,
                unmatched: collection.unmatched,
                zeroMatch: result.zeroMatch,
                query: result.query,
                hint: result.hint,
            }, barelyResult);
        }
        return compereResult(matchedResult, barelyResult);
    }
}
exports.countPattern = countPattern;
function compereResult(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
a, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
b) {
    var _a;
    cLog('current: %s %O\nbarely: %s %O', a.type, a.hint, b === null || b === void 0 ? void 0 : b.type, b === null || b === void 0 ? void 0 : b.hint);
    if (b == null) {
        return a;
    }
    if (a.type === 'MATCHED' || a.type === 'MATCHED_ZERO' || a.type === 'UNEXPECTED_EXTRA_NODE') {
        return a;
    }
    const result = (_a = [a, b].sort((a, b) => { var _a, _b, _c, _d; return ((_b = (_a = b.hint.missing) === null || _a === void 0 ? void 0 : _a.barelyMatchedElements) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = a.hint.missing) === null || _c === void 0 ? void 0 : _c.barelyMatchedElements) !== null && _d !== void 0 ? _d : 0); })[0]) !== null && _a !== void 0 ? _a : a;
    return result;
}
