"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchesSelector = void 0;
const ml_spec_1 = require("@markuplint/ml-spec");
const debug_1 = require("./debug");
const utils_1 = require("./utils");
function matchesSelector(query, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node, specs, depth) {
    const nodeLog = debug_1.cmLog.extend(`node#${depth}`);
    const { selector, hasText, hasCustom } = optCondition(query, specs);
    if (node == null) {
        if (hasText) {
            nodeLog('<#text>.matches(%s) => ""', query);
            return {
                type: 'MATCHED_ZERO',
                matched: [],
                unmatched: [],
                zeroMatch: true,
                query,
                hint: {},
            };
        }
        return {
            type: 'MISSING_NODE',
            matched: [],
            unmatched: [],
            zeroMatch: false,
            query,
            hint: {},
        };
    }
    if (node.is(node.TEXT_NODE)) {
        if (hasText) {
            nodeLog('<#text>.matches(%s) => "%s"', query, node.raw.trim());
            return {
                type: 'MATCHED',
                matched: [node],
                unmatched: [],
                zeroMatch: true,
                query,
                hint: {},
            };
        }
        if (node.isWhitespace()) {
            nodeLog('<#text>.matches(%s) => WHITESPACE', query);
            return {
                type: 'MATCHED',
                matched: [node],
                unmatched: [],
                zeroMatch: true,
                query,
                hint: {},
            };
        }
        // Disallows a text node
        return {
            type: 'UNEXPECTED_EXTRA_NODE',
            matched: [],
            unmatched: [node],
            zeroMatch: false,
            query,
            hint: {},
        };
    }
    if (node.is(node.MARKUPLINT_PREPROCESSOR_BLOCK)) {
        nodeLog('%s.matches(%s) => PBlock', node.raw, query);
        return {
            type: 'MATCHED',
            matched: [node],
            unmatched: [],
            zeroMatch: !!hasText,
            query,
            hint: {},
        };
    }
    if (node.is(node.ELEMENT_NODE)) {
        if (node.elementType !== 'html' && hasCustom) {
            nodeLog('%s.matches(%s) => CustomElement', node.raw, query);
            return {
                type: 'MATCHED',
                matched: [node],
                unmatched: [],
                zeroMatch: !!hasText,
                query,
                hint: {},
            };
        }
        const result = (0, utils_1.matches)(selector, node, specs);
        nodeLog('%s.matches(%s) => %s', node.raw, query, result.matched);
        if (result.matched) {
            return {
                type: 'MATCHED',
                matched: [node],
                unmatched: [],
                zeroMatch: !!hasText,
                query,
                hint: {},
            };
        }
        if (hasText) {
            return {
                type: 'UNMATCHED_SELECTOR_BUT_MAY_EMPTY',
                matched: [],
                unmatched: [node],
                zeroMatch: true,
                query,
                hint: (0, utils_1.cleanObject)({
                    not: result.not,
                }),
            };
        }
        return {
            type: 'UNMATCHED_SELECTORS',
            matched: [],
            unmatched: [node],
            zeroMatch: false,
            query,
            hint: (0, utils_1.cleanObject)({
                not: result.not,
            }),
        };
    }
    return {
        type: 'MATCHED',
        matched: [node],
        unmatched: [],
        zeroMatch: !!hasText,
        query,
        hint: {},
    };
}
exports.matchesSelector = matchesSelector;
const conditionWithoutSpecs = {
    '#custom': {
        selector: '#custom',
        hasCustom: true,
        hasText: false,
    },
    '#text': {
        selector: '#text',
        hasCustom: false,
        hasText: true,
    },
};
const optConditionSpecsBaseCaches = new Map();
function optCondition(query, specs) {
    var _a;
    const condWithoutSpecs = conditionWithoutSpecs[query];
    if (condWithoutSpecs) {
        return condWithoutSpecs;
    }
    const queryCaches = (_a = optConditionSpecsBaseCaches.get(specs)) !== null && _a !== void 0 ? _a : new Map();
    const cached = queryCaches.get(query);
    if (cached) {
        return cached;
    }
    let hasCustom = false;
    let hasText = false;
    const selector = query.replace(/^(?::model\(([^)]+)\)|#([a-z-]+))(.*)$/, (_, $model, _model, $last) => {
        const _selectors = (0, ml_spec_1.contentModelCategoryToTagNames)(`#${$model !== null && $model !== void 0 ? $model : _model}`, specs.def);
        if (_selectors.length === 0) {
            throw new Error(`${$model !== null && $model !== void 0 ? $model : _model} is empty`);
        }
        const selectors = [];
        for (const selector of _selectors) {
            if (selector === '#custom') {
                hasCustom = true;
                continue;
            }
            if (selector === '#text') {
                hasText = true;
                continue;
            }
            selectors.push(selector);
        }
        return `:is(${selectors.join(',')})${$last !== null && $last !== void 0 ? $last : ''}`;
    });
    const result = {
        selector,
        hasCustom,
        hasText,
    };
    queryCaches.set(query, result);
    optConditionSpecsBaseCaches.set(specs, queryCaches);
    return result;
}
