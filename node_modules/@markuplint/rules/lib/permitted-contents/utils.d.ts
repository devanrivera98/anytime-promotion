import type { ChildNode, Element, Hints, MissingNodeReason, RepeatSign, Specs } from './types';
import type { PermittedContentPattern, PermittedContentChoice, PermittedContentOneOrMore, PermittedContentOptional, PermittedContentRequire, PermittedContentTransparent, PermittedContentZeroOrMore, Model } from '@markuplint/ml-spec';
import type { ReadonlyDeep } from 'type-fest';
export declare function getChildNodesWithoutWhitespaces(el: Element): ChildNode[];
export declare function isModel(model: ReadonlyDeep<Model | PermittedContentPattern[]>): model is ReadonlyDeep<Model>;
export declare function matches(selector: string, node: ChildNode, specs: Specs): {
    matched: boolean;
    not?: undefined;
} | {
    matched: boolean;
    not: ChildNode | undefined;
};
export declare function isRequire(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentRequire>;
export declare function isOptional(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentOptional>;
export declare function isOneOrMore(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentOneOrMore>;
export declare function isZeroOrMore(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentZeroOrMore>;
export declare function isChoice(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentChoice>;
export declare function isTransparent(content: ReadonlyDeep<PermittedContentPattern>): content is ReadonlyDeep<PermittedContentTransparent>;
export declare function normalizeModel(pattern: ReadonlyDeep<PermittedContentRequire> | ReadonlyDeep<PermittedContentOptional> | ReadonlyDeep<PermittedContentOneOrMore> | ReadonlyDeep<PermittedContentZeroOrMore>): {
    model: ReadonlyDeep<PermittedContentPattern[] | Model>;
    min: number;
    max: number;
    repeat: RepeatSign;
    missingType: MissingNodeReason | undefined;
};
export declare function mergeHints(a: Readonly<Hints>, b: Readonly<Hints>): Partial<{
    missing: Partial<{
        barelyMatchedElements?: number | undefined;
        need?: string | undefined;
    }> | undefined;
    max?: number | undefined;
    not?: ChildNode | undefined;
    transparent?: Element | undefined;
}>;
export declare function cleanObject<T extends Object>(object: T): Partial<T>;
export declare class Collection {
    #private;
    constructor(origin: readonly ChildNode[]);
    get matched(): ChildNode[];
    get matchedCount(): number;
    get nodes(): ChildNode[];
    get unmatched(): ChildNode[];
    addMatched(nodes: ChildNode[]): boolean;
    back(): void;
    lock(): void;
    max(max: number): void;
    toString(highlightExtraNodes?: boolean): string;
}
export declare class UnsupportedError extends Error {
}
export declare function modelLog(model: ReadonlyDeep<Model | PermittedContentPattern[]>, repeat: RepeatSign): string;
