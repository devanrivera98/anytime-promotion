"use strict";
var _Collection_locked, _Collection_matched, _Collection_nodes, _Collection_origin;
Object.defineProperty(exports, "__esModule", { value: true });
exports.modelLog = exports.UnsupportedError = exports.Collection = exports.cleanObject = exports.mergeHints = exports.normalizeModel = exports.isTransparent = exports.isChoice = exports.isZeroOrMore = exports.isOneOrMore = exports.isOptional = exports.isRequire = exports.matches = exports.isModel = exports.getChildNodesWithoutWhitespaces = void 0;
const tslib_1 = require("tslib");
const selector_1 = require("@markuplint/selector");
const debug_1 = require("./debug");
const represent_transparent_nodes_1 = require("./represent-transparent-nodes");
const getChildNodesWithoutWhitespacesCaches = new Map();
function getChildNodesWithoutWhitespaces(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el) {
    let nodes = getChildNodesWithoutWhitespacesCaches.get(el);
    if (nodes) {
        return nodes;
    }
    nodes = Array.from(el.childNodes).filter(node => {
        return !(node.is(node.TEXT_NODE) && node.isWhitespace());
    });
    getChildNodesWithoutWhitespacesCaches.set(el, nodes);
    return nodes;
}
exports.getChildNodesWithoutWhitespaces = getChildNodesWithoutWhitespaces;
function isModel(model) {
    if (typeof model === 'string') {
        return true;
    }
    let modelMode = false;
    for (const m of model) {
        if (typeof m === 'string') {
            modelMode = true;
            continue;
        }
        if (modelMode) {
            throw new TypeError(`Invalid schema: ${JSON.stringify(model)}`);
        }
    }
    return modelMode;
}
exports.isModel = isModel;
function matches(selector, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node, specs) {
    const selectorResult = (0, selector_1.createSelector)(selector, specs).search(node);
    const matched = selectorResult.filter((r) => r.matched);
    if (matched.length > 0) {
        return {
            matched: true,
        };
    }
    const not = selectorResult
        .map(r => { var _a; return (r.matched ? [] : (_a = r.not) !== null && _a !== void 0 ? _a : []); })
        .flat()
        .map(descendants)
        .flat()
        .shift();
    return {
        matched: false,
        not,
    };
}
exports.matches = matches;
function descendants(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
selectorResult) {
    let nodes = selectorResult.nodes.slice();
    while (selectorResult.has.length > 0) {
        for (const dep of selectorResult.has) {
            if (dep.has.length === 0) {
                nodes = dep.nodes;
                continue;
            }
            selectorResult = dep;
            continue;
        }
        break;
    }
    return nodes;
}
function isRequire(content) {
    return 'require' in content;
}
exports.isRequire = isRequire;
function isOptional(content) {
    return 'optional' in content;
}
exports.isOptional = isOptional;
function isOneOrMore(content) {
    return 'oneOrMore' in content;
}
exports.isOneOrMore = isOneOrMore;
function isZeroOrMore(content) {
    return 'zeroOrMore' in content;
}
exports.isZeroOrMore = isZeroOrMore;
function isChoice(content) {
    return 'choice' in content;
}
exports.isChoice = isChoice;
function isTransparent(content) {
    return 'transparent' in content;
}
exports.isTransparent = isTransparent;
function normalizeModel(pattern) {
    var _a, _b, _c, _d, _e;
    let model;
    let min;
    let max;
    let repeat;
    let missingType;
    if (isRequire(pattern)) {
        model = pattern.require;
        min = (_a = pattern.min) !== null && _a !== void 0 ? _a : 1;
        max = Math.max((_b = pattern.max) !== null && _b !== void 0 ? _b : 1, min);
        missingType = 'MISSING_NODE_REQUIRED';
    }
    else if (isOptional(pattern)) {
        model = pattern.optional;
        min = 0;
        max = Math.max((_c = pattern.max) !== null && _c !== void 0 ? _c : 1, 1);
    }
    else if (isOneOrMore(pattern)) {
        model = pattern.oneOrMore;
        min = 1;
        max = Math.max((_d = pattern.max) !== null && _d !== void 0 ? _d : Infinity, 1);
        missingType = 'MISSING_NODE_ONE_OR_MORE';
    }
    else if (isZeroOrMore(pattern)) {
        model = pattern.zeroOrMore;
        min = 0;
        max = Math.max((_e = pattern.max) !== null && _e !== void 0 ? _e : Infinity, 1);
    }
    else {
        throw new Error('Unreachable code');
    }
    if (min === 0 && max === 1) {
        repeat = '?';
    }
    else if (min === 0 && !Number.isFinite(max)) {
        repeat = '*';
    }
    else if (min === 1 && max === 1) {
        repeat = '';
    }
    else if (min === 1 && !Number.isFinite(max)) {
        repeat = '+';
    }
    else {
        repeat = `{${min},${max}}`;
    }
    return {
        model,
        min,
        max,
        repeat,
        missingType,
    };
}
exports.normalizeModel = normalizeModel;
function mergeHints(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
a, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
b) {
    const missing = [a.missing, b.missing].sort((a, b) => { var _a, _b; return ((_a = b === null || b === void 0 ? void 0 : b.barelyMatchedElements) !== null && _a !== void 0 ? _a : 0) - ((_b = a === null || a === void 0 ? void 0 : a.barelyMatchedElements) !== null && _b !== void 0 ? _b : 0); })[0];
    return cleanObject({
        ...a,
        ...b,
        missing: missing && cleanObject(missing),
    });
}
exports.mergeHints = mergeHints;
function cleanObject(object) {
    const newObject = {};
    Object.entries(object).forEach(([key, value]) => {
        if (value !== undefined) {
            newObject[key] = value;
        }
    });
    return newObject;
}
exports.cleanObject = cleanObject;
class Collection {
    constructor(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    origin) {
        _Collection_locked.set(this, new Set());
        _Collection_matched.set(this, new Set());
        _Collection_nodes.set(this, void 0);
        _Collection_origin.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _Collection_origin, origin.slice(), "f");
        tslib_1.__classPrivateFieldSet(this, _Collection_nodes, new Set(tslib_1.__classPrivateFieldGet(this, _Collection_origin, "f")), "f");
    }
    get matched() {
        return Array.from(tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f"));
    }
    get matchedCount() {
        return tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").size;
    }
    get nodes() {
        return tslib_1.__classPrivateFieldGet(this, _Collection_origin, "f").slice();
    }
    get unmatched() {
        return Array.from(tslib_1.__classPrivateFieldGet(this, _Collection_nodes, "f")).filter(n => !tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").has(n));
    }
    addMatched(
    // eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
    nodes) {
        const i = tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").size;
        for (const node of nodes) {
            if (!tslib_1.__classPrivateFieldGet(this, _Collection_nodes, "f").has(node)) {
                throw new ReferenceError(`External Node: ${node.nodeName}`);
            }
            tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").add(node);
        }
        return i < tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").size;
    }
    back() {
        tslib_1.__classPrivateFieldSet(this, _Collection_matched, new Set(tslib_1.__classPrivateFieldGet(this, _Collection_locked, "f")), "f");
    }
    lock() {
        tslib_1.__classPrivateFieldSet(this, _Collection_locked, new Set(tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f")), "f");
    }
    max(max) {
        const sliced = Array.from(tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f")).slice(max);
        sliced.forEach(n => tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").delete(n));
    }
    toString(highlightExtraNodes = false) {
        const out = [];
        for (const n of tslib_1.__classPrivateFieldGet(this, _Collection_origin, "f")) {
            const raw = n.is(n.TEXT_NODE) ? `:text(${n.raw.replace(/\n/g, '\\n')})` : n.raw;
            if (tslib_1.__classPrivateFieldGet(this, _Collection_locked, "f").has(n)) {
                if (represent_transparent_nodes_1.transparentMode.has(n)) {
                    out.push(debug_1.bgBlue.bold(raw));
                }
                else {
                    out.push(debug_1.bgGreen.bold(raw));
                }
                continue;
            }
            if (tslib_1.__classPrivateFieldGet(this, _Collection_matched, "f").has(n)) {
                if (represent_transparent_nodes_1.transparentMode.has(n)) {
                    out.push(debug_1.blue.bold(raw));
                }
                else {
                    out.push(debug_1.green.bold(raw));
                }
                continue;
            }
            if (highlightExtraNodes) {
                if (represent_transparent_nodes_1.transparentMode.has(n)) {
                    out.push(debug_1.bgMagenta.bold(raw));
                }
                else {
                    out.push(debug_1.bgRed.bold(raw));
                }
                continue;
            }
            if (represent_transparent_nodes_1.transparentMode.has(n)) {
                out.push((0, debug_1.cyan)(raw));
            }
            else {
                out.push(raw);
            }
        }
        return `[ ${out.join(', ')} ]`;
    }
}
exports.Collection = Collection;
_Collection_locked = new WeakMap(), _Collection_matched = new WeakMap(), _Collection_nodes = new WeakMap(), _Collection_origin = new WeakMap();
class UnsupportedError extends Error {
}
exports.UnsupportedError = UnsupportedError;
function modelLog(model, repeat) {
    if (!isModel(model)) {
        return orderLog(model, repeat);
    }
    if (typeof model === 'string') {
        return `<${model}>${repeat}`;
    }
    return `(<${model.join('>|<')}>)${repeat}`;
}
exports.modelLog = modelLog;
function orderLog(order, repeat) {
    return order.length === 1 && order[0]
        ? markRepeat(patternLog(order[0]), repeat)
        : markRepeat(order.map(pattern => patternLog(pattern)).join(''), repeat);
}
function patternLog(pattern) {
    if (isTransparent(pattern)) {
        // 適当
        return `:transparent(${modelLog(pattern.transparent, '')})`;
    }
    if (isChoice(pattern)) {
        return `(${pattern.choice.map(candidate => orderLog(candidate, '')).join('|')})`;
    }
    const { model, repeat } = normalizeModel(pattern);
    return modelLog(model, repeat);
}
function markRepeat(pattern, repeat) {
    return repeat ? `(${pattern})${repeat}` : pattern;
}
