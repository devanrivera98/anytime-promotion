"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.representTransparentNodes = exports.transparentMode = void 0;
const ml_spec_1 = require("@markuplint/ml-spec");
const order_1 = require("./order");
const utils_1 = require("./utils");
exports.transparentMode = new Map();
function representTransparentNodes(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
nodes, specs, options) {
    var _a;
    const result = [];
    const errors = [];
    const parent = (_a = nodes[0]) === null || _a === void 0 ? void 0 : _a.parentElement;
    if (parent) {
        const { errors: parentErrors } = representTransparentNodes([parent], specs, options);
        errors.push(...parentErrors);
    }
    for (const node of nodes) {
        if (!node.is(node.ELEMENT_NODE)) {
            result.push(node);
            continue;
        }
        const models = (0, ml_spec_1.getContentModel)(node, specs.specs);
        if (models == null || typeof models === 'boolean') {
            result.push(node);
            continue;
        }
        const noTransparentModels = models.filter(m => !(0, utils_1.isTransparent)(m));
        if (noTransparentModels.length === models.length) {
            result.push(node);
            continue;
        }
        const collection = new utils_1.Collection((0, utils_1.getChildNodesWithoutWhitespaces)(node));
        let unmatched;
        if (noTransparentModels.length > 0) {
            const result = (0, order_1.order)(noTransparentModels, collection.unmatched, specs, options, Infinity);
            unmatched = result.unmatched;
        }
        else {
            unmatched = collection.unmatched;
        }
        const transparent = models.find(m => (0, utils_1.isTransparent)(m));
        if (!transparent || !(0, utils_1.isTransparent)(transparent)) {
            throw new Error('Unreachable code');
        }
        for (const _child of unmatched) {
            const child = _child;
            if (exports.transparentMode.has(child)) {
                continue;
            }
            exports.transparentMode.set(child, true);
            if (child.is(child.ELEMENT_NODE)) {
                const transparentCondMatched = (0, utils_1.matches)(transparent.transparent, child, specs);
                if (!transparentCondMatched.matched) {
                    errors.push({
                        type: 'TRANSPARENT_MODEL_DISALLOWS',
                        matched: [],
                        unmatched: [node],
                        zeroMatch: false,
                        query: transparent.transparent,
                        hint: {
                            not: transparentCondMatched.not,
                            transparent: node,
                        },
                    });
                    continue;
                }
            }
            result.push(child);
        }
    }
    return {
        nodes: result,
        errors,
    };
}
exports.representTransparentNodes = representTransparentNodes;
