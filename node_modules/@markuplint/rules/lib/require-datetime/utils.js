"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCandidateDatetimeString = exports.parseADatetime = void 0;
const tslib_1 = require("tslib");
const chrono = tslib_1.__importStar(require("chrono-node"));
const defaultLangs = ['en', 'ja', 'fr', 'nl', 'ru', 'de', 'pt', 'zh'];
/**
 * Datetime-ish text to a datetime data
 *
 * @param content
 * @param langs
 * @param base Reference date for a test
 * @returns
 */
function parseADatetime(content, langs, base) {
    var _a;
    const date = parseTryMultipleLangs(content, langs, base);
    if (!date) {
        return null;
    }
    const data = {};
    if (date.isCertain('year')) {
        data.year = date.get('year');
    }
    if (date.isCertain('month')) {
        data.month = date.get('month');
    }
    if (date.isCertain('day')) {
        data.day = date.get('day');
    }
    if (date.isCertain('hour')) {
        data.hour = date.get('hour');
    }
    if (date.isCertain('hour')) {
        data.minute = (_a = date.get('minute')) !== null && _a !== void 0 ? _a : 0;
    }
    if (date.isCertain('second')) {
        data.second = date.get('second');
    }
    if (date.isCertain('millisecond')) {
        data.ms = date.get('millisecond');
    }
    const datetime = {
        datetime: data,
    };
    if (date.isCertain('timezoneOffset')) {
        datetime.zone = date.get('timezoneOffset');
    }
    return datetime;
}
exports.parseADatetime = parseADatetime;
function getCandidateDatetimeString(content, langs = defaultLangs) {
    const date = parseADatetime(content, langs);
    if (!date) {
        return null;
    }
    let datetimeStr = toDatetimeString(date.datetime);
    if (!datetimeStr) {
        return null;
    }
    if (date.zone != null) {
        const plusMinus = date.zone < 0 ? '-' : '+';
        const hour = Math.floor(Math.abs(date.zone) / 60);
        const minute = Math.abs(date.zone) % 60;
        datetimeStr += `${plusMinus}${f(hour, 2)}${f(minute, 2)}`;
    }
    return datetimeStr;
}
exports.getCandidateDatetimeString = getCandidateDatetimeString;
function toDatetimeString(date) {
    if (only(date, ['year', 'month'])) {
        return `${f(date.year, 4)}-${f(date.month, 2)}`;
    }
    if (only(date, ['year', 'month', 'day'])) {
        return `${f(date.year, 4)}-${f(date.month, 2)}-${f(date.day, 2)}`;
    }
    if (only(date, ['month', 'day'])) {
        return `${f(date.month, 2)}-${f(date.day, 2)}`;
    }
    if (only(date, ['hour', 'minute'])) {
        return `${f(date.hour, 2)}:${f(date.minute, 2)}`;
    }
    if (only(date, ['hour', 'minute', 'second'])) {
        return `${f(date.hour, 2)}:${f(date.minute, 2)}:${f(date.second, 2)}`;
    }
    if (only(date, ['hour', 'minute', 'second', 'ms'])) {
        return `${f(date.hour, 2)}:${f(date.minute, 2)}:${f(date.second, 2)}.${date.ms}`;
    }
    if (only(date, ['year', 'month', 'day', 'hour', 'minute'])) {
        return `${f(date.year, 4)}-${f(date.month, 2)}-${f(date.day, 2)}T${f(date.hour, 2)}:${f(date.minute, 2)}`;
    }
    if (only(date, ['year', 'month', 'day', 'hour', 'minute', 'second'])) {
        return `${f(date.year, 4)}-${f(date.month, 2)}-${f(date.day, 2)}T${f(date.hour, 2)}:${f(date.minute, 2)}:${f(date.second, 2)}`;
    }
    if (only(date, ['year', 'month', 'day', 'hour', 'minute', 'second', 'ms'])) {
        return `${f(date.year, 4)}-${f(date.month, 2)}-${f(date.day, 2)}T${f(date.hour, 2)}:${f(date.minute, 2)}:${f(date.second, 2)}.${date.ms}`;
    }
    return null;
}
function parseTryMultipleLangs(content, langs, base) {
    for (const lang of langs) {
        const results = chrono[lang].casual.parse(content, base);
        // Is not multiple datetime contents
        if (results.length < 1) {
            continue;
        }
        const result = results[0];
        if (!result) {
            continue;
        }
        // Is not a range or period
        if (result.end) {
            continue;
        }
        return result.start;
    }
    return null;
}
function only(date, keys) {
    const list = Object.keys(date);
    for (const exists of list) {
        if (!keys.includes(exists)) {
            return false;
        }
    }
    return true;
}
/**
 * Formatter
 *
 * @param n
 * @param pad zero padding
 * @returns
 */
function f(n, pad) {
    return n.toString(10).padStart(pad, '0');
}
