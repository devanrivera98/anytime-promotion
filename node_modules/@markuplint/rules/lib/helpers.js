"use strict";
var _Collection_items;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepCopy = exports.Collection = exports.getOwnedLabel = exports.accnameMayBeMutable = exports.toNormalizedValue = exports.isValidAttr = exports.rePCENChar = exports.match = exports.attrMatches = void 0;
const tslib_1 = require("tslib");
// @ts-ignore
const structured_clone_1 = tslib_1.__importDefault(require("@ungap/structured-clone"));
const attr_check_1 = require("./attr-check");
function attrMatches(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node, condition) {
    if (condition == null) {
        return true;
    }
    const condSelector = typeof condition === 'string' ? condition : condition.join(',');
    return node.matches(condSelector);
}
exports.attrMatches = attrMatches;
function match(needle, pattern) {
    const matches = pattern.match(/^\/(.*)\/(i|g|m)*$/);
    if (matches && matches[1]) {
        const re = matches[1];
        const flag = matches[2];
        return new RegExp(re, flag).test(needle);
    }
    return needle === pattern;
}
exports.match = match;
/**
 * PotentialCustomElementName
 *
 * @see https://spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname
 *
 * > PotentialCustomElementName ::=
 * >   [a-z] (PCENChar)* '-' (PCENChar)*
 * > PCENChar ::=
 * >   "-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
 * >   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
 * > This uses the EBNF notation from the XML specification. [XML]
 *
 * ASCII-case-insensitively.
 * Originally, it is not possible to define a name including ASCII upper alphas in the custom element, but it is not treated as illegal by the HTML parser.
 */
exports.rePCENChar = [
    '\\-',
    '\\.',
    '[0-9]',
    '_',
    '[a-z]',
    '\u00B7',
    '[\u00C0-\u00D6]',
    '[\u00D8-\u00F6]',
    '[\u00F8-\u037D]',
    '[\u037F-\u1FFF]',
    '[\u200C-\u200D]',
    '[\u203F-\u2040]',
    '[\u2070-\u218F]',
    '[\u2C00-\u2FEF]',
    '[\u3001-\uD7FF]',
    '[\uF900-\uFDCF]',
    '[\uFDF0-\uFFFD]',
    '[\uD800-\uDBFF][\uDC00-\uDFFF]',
].join('|');
function isValidAttr(t, name, value, isDynamicValue, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
node, attrSpecs, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
log) {
    let invalid = false;
    const spec = attrSpecs.find(s => s.name.toLowerCase() === name.toLowerCase());
    log && log('Spec of the %s attr: %o', name, spec);
    invalid = (0, attr_check_1.attrCheck)(t, name, value, false, spec);
    if (invalid === false &&
        spec &&
        spec.condition != null &&
        !node.hasSpreadAttr &&
        !attrMatches(node, spec.condition)) {
        invalid = {
            invalidType: 'non-existent',
            message: t('{0} is {1}', t('the "{0*}" {1}', name, 'attribute'), 'disallowed'),
        };
    }
    if (invalid !== false && invalid.invalidType === 'invalid-value' && isDynamicValue) {
        invalid = false;
    }
    return invalid;
}
exports.isValidAttr = isValidAttr;
function toNormalizedValue(value, spec) {
    let normalized = value;
    if (!spec.caseSensitive) {
        normalized = normalized.toLowerCase();
    }
    if (typeof spec.type === 'string') {
        if (spec.type[0] === '<') {
            normalized = normalized.toLowerCase().trim().replace(/\s+/g, ' ');
        }
    }
    else {
        if ('token' in spec.type) {
            if (spec.type.caseInsensitive) {
                normalized = normalized.toLowerCase();
            }
            if (!spec.type.disallowToSurroundBySpaces) {
                normalized = normalized.trim();
            }
            if (spec.type.separator === 'space') {
                normalized = normalized.replace(/\s+/g, ' ');
            }
            if (spec.type.separator === 'comma') {
                normalized = normalized.replace(/\s*,\s*/g, ',');
            }
        }
    }
    return normalized;
}
exports.toNormalizedValue = toNormalizedValue;
function accnameMayBeMutable(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
document) {
    if (el.hasMutableAttributes() || el.hasMutableChildren(true)) {
        return true;
    }
    const ownedLabel = getOwnedLabel(el, document);
    if (ownedLabel && (ownedLabel.hasMutableAttributes() || ownedLabel.hasMutableChildren(true))) {
        return true;
    }
    return false;
}
exports.accnameMayBeMutable = accnameMayBeMutable;
const labelable = ['button', 'input:not([type=hidden])', 'meter', 'output', 'progress', 'select', 'textarea'];
function getOwnedLabel(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
el, 
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
document) {
    if (!labelable.some(cond => el.matches(cond))) {
        return null;
    }
    let ownedLabel = el.closest('label');
    if (!ownedLabel) {
        const id = el.getAttribute('id');
        if (id) {
            ownedLabel = document.querySelector(`label[for="${id}"]`);
        }
    }
    return ownedLabel;
}
exports.getOwnedLabel = getOwnedLabel;
class Collection {
    constructor(...items) {
        _Collection_items.set(this, new Set());
        this.add(...items);
    }
    [(_Collection_items = new WeakMap(), Symbol.iterator)]() {
        return tslib_1.__classPrivateFieldGet(this, _Collection_items, "f").values();
    }
    add(...items) {
        for (const item of items) {
            if (item == null) {
                continue;
            }
            tslib_1.__classPrivateFieldGet(this, _Collection_items, "f").add(item);
        }
    }
    toArray() {
        return Object.freeze(Array.from(tslib_1.__classPrivateFieldGet(this, _Collection_items, "f")));
    }
}
exports.Collection = Collection;
function deepCopy(value) {
    return (0, structured_clone_1.default)(value);
}
exports.deepCopy = deepCopy;
