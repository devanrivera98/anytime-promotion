"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_core_1 = require("@markuplint/ml-core");
const attr_check_1 = require("../attr-check");
const debug_1 = require("../debug");
const helpers_1 = require("../helpers");
const log = debug_1.log.extend('invalid-attr');
exports.default = (0, ml_core_1.createRule)({
    defaultOptions: {},
    async verify({ document, report, t }) {
        await document.walkOn('Attr', attr => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            // Default
            const allowToAddPropertiesForPretender = (_a = attr.rule.options.allowToAddPropertiesForPretender) !== null && _a !== void 0 ? _a : true;
            if (attr.isDirective) {
                return;
            }
            const attrSpecs = (0, ml_core_1.getAttrSpecs)(attr.ownerElement, document.specs);
            const attrName = attr.nameNode;
            const name = attr.name;
            if (attr.ownerElement.elementType === 'html' && attr.candidate) {
                const message = t('{0} is {1:c}', t('the "{0*}" {1}', name, 'attribute'), 'disallowed') +
                    t('. ') +
                    t('Did you mean "{0}"?', attr.candidate);
                report({
                    scope: attr,
                    line: attrName === null || attrName === void 0 ? void 0 : attrName.startLine,
                    col: attrName === null || attrName === void 0 ? void 0 : attrName.startCol,
                    raw: attrName === null || attrName === void 0 ? void 0 : attrName.raw,
                    message: message,
                });
                return;
            }
            const valueNode = attr.valueNode;
            const value = attr.value;
            if (attr.rule.options.ignoreAttrNamePrefix != null) {
                const ignoreAttrNamePrefixes = Array.isArray(attr.rule.options.ignoreAttrNamePrefix)
                    ? attr.rule.options.ignoreAttrNamePrefix
                    : [attr.rule.options.ignoreAttrNamePrefix];
                if (ignoreAttrNamePrefixes.some(prefix => name.indexOf(prefix) === 0)) {
                    return;
                }
            }
            let invalid = false;
            const allowAttrs = {};
            const disallowAttrs = {};
            if (attr.rule.options.allowAttrs) {
                if (Array.isArray(attr.rule.options.allowAttrs)) {
                    for (const allowAttr of attr.rule.options.allowAttrs) {
                        if (typeof allowAttr === 'string') {
                            allowAttrs[allowAttr] = { type: 'Any' };
                            continue;
                        }
                        if (isValueRule(allowAttr.value)) {
                            allowAttrs[allowAttr.name] = allowAttr.value;
                            continue;
                        }
                        allowAttrs[allowAttr.name] = { type: allowAttr.value };
                    }
                }
                else {
                    for (const [attrName, valueRule] of Object.entries(attr.rule.options.allowAttrs)) {
                        allowAttrs[attrName] = valueRule;
                    }
                }
            }
            if (attr.rule.options.disallowAttrs) {
                if (Array.isArray(attr.rule.options.disallowAttrs)) {
                    for (const disallowAttr of attr.rule.options.disallowAttrs) {
                        if (typeof disallowAttr === 'string') {
                            disallowAttrs[disallowAttr] = { type: 'Any' };
                            continue;
                        }
                        if (isValueRule(disallowAttr.value)) {
                            disallowAttrs[disallowAttr.name] = disallowAttr.value;
                            continue;
                        }
                        disallowAttrs[disallowAttr.name] = { type: disallowAttr.value };
                    }
                }
                else {
                    for (const [attrName, valueRule] of Object.entries(attr.rule.options.disallowAttrs)) {
                        disallowAttrs[attrName] = valueRule;
                    }
                }
            }
            if (attr.rule.options.attrs) {
                for (const [attrName, valueRule] of Object.entries(attr.rule.options.attrs)) {
                    if ('disallowed' in valueRule) {
                        disallowAttrs[attrName] = { type: 'Any' };
                    }
                    else {
                        allowAttrs[attrName] = valueRule;
                    }
                }
            }
            const allowValue = (_b = allowAttrs[name]) !== null && _b !== void 0 ? _b : null;
            const disallowValue = (_c = disallowAttrs[name]) !== null && _c !== void 0 ? _c : null;
            if (allowValue) {
                if ('enum' in allowValue) {
                    invalid = (0, attr_check_1.attrCheck)(t, name.toLowerCase(), value, true, {
                        name,
                        type: {
                            enum: allowValue.enum,
                        },
                        description: '',
                    });
                }
                else if ('pattern' in allowValue) {
                    if (!(0, helpers_1.match)(value, allowValue.pattern)) {
                        invalid = {
                            invalidType: 'invalid-value',
                            message: t('{0} is unmatched with the below patterns: {1}', t('the "{0*}" {1}', name, 'attribute'), allowValue.pattern),
                        };
                    }
                }
                else if ('type' in allowValue) {
                    invalid = (0, attr_check_1.attrCheck)(t, name, value, true, { name, type: allowValue.type, description: '' });
                }
            }
            else if (disallowValue) {
                if ('enum' in disallowValue) {
                    const checkResult = (0, attr_check_1.attrCheck)(t, name.toLowerCase(), value, true, {
                        name,
                        type: {
                            enum: disallowValue.enum,
                        },
                        description: '',
                    });
                    if (checkResult === false) {
                        invalid = {
                            invalidType: 'invalid-value',
                            message: t('{0} is disallowed to accept the following values: {1}', t('the "{0*}" {1}', name, 'attribute'), t(disallowValue.enum)),
                        };
                    }
                }
                else if ('pattern' in disallowValue) {
                    if ((0, helpers_1.match)(value, disallowValue.pattern)) {
                        invalid = {
                            invalidType: 'invalid-value',
                            message: t('{0} is matched with the below disallowed patterns: {1}', t('the "{0*}" {1}', name, 'attribute'), disallowValue.pattern),
                        };
                    }
                }
                else if ('type' in disallowValue) {
                    if (disallowValue.type === 'Any') {
                        invalid = {
                            invalidType: 'non-existent',
                            message: t('{0} is disallowed', t('the "{0*}" {1}', name, 'attribute')),
                        };
                    }
                    else {
                        const checkResult = (0, attr_check_1.attrCheck)(t, name, value, true, {
                            name,
                            type: disallowValue.type,
                            description: '',
                        });
                        if (checkResult === false) {
                            invalid = {
                                invalidType: 'invalid-value',
                                message: t('{0} is disallowed', t('{0} of {1}', t('the {0}', 'type'), t('the "{0*}" {1}', name, 'attribute'))),
                            };
                        }
                    }
                }
            }
            else if (attr.ownerElement.elementType === 'html' && attrSpecs) {
                log('Checking %s[%s="%s"]', attr.nodeName, name, value);
                invalid = (0, helpers_1.isValidAttr)(t, name, value, attr.isDynamicValue || false, attr.ownerElement, attrSpecs, log);
            }
            if (invalid !== false) {
                switch (invalid.invalidType) {
                    case 'disallowed-attr': {
                        report({
                            scope: attr,
                            message: invalid.message,
                        });
                        break;
                    }
                    case 'invalid-value': {
                        if (attr.isDynamicValue) {
                            break;
                        }
                        report({
                            scope: attr,
                            message: invalid.message,
                            line: ((_d = valueNode === null || valueNode === void 0 ? void 0 : valueNode.startLine) !== null && _d !== void 0 ? _d : 0) + ((_f = (_e = invalid.loc) === null || _e === void 0 ? void 0 : _e.line) !== null && _f !== void 0 ? _f : 0),
                            col: invalid.loc && invalid.loc.line > 0
                                ? ((_g = invalid.loc) === null || _g === void 0 ? void 0 : _g.col) + 1
                                : ((_h = valueNode === null || valueNode === void 0 ? void 0 : valueNode.startCol) !== null && _h !== void 0 ? _h : 0) + ((_k = (_j = invalid.loc) === null || _j === void 0 ? void 0 : _j.col) !== null && _k !== void 0 ? _k : 0),
                            raw: (_m = (_l = invalid.loc) === null || _l === void 0 ? void 0 : _l.raw) !== null && _m !== void 0 ? _m : value,
                        });
                        break;
                    }
                    case 'non-existent': {
                        if (allowToAddPropertiesForPretender && ((_o = attr.ownerElement.pretenderContext) === null || _o === void 0 ? void 0 : _o.type) === 'origin') {
                            return;
                        }
                        const spec = (0, ml_core_1.getSpec)(attr.ownerElement, document.specs.specs);
                        if (spec === null || spec === void 0 ? void 0 : spec.possibleToAddProperties) {
                            return;
                        }
                        report({
                            scope: attr,
                            message: invalid.message,
                            line: attrName === null || attrName === void 0 ? void 0 : attrName.startLine,
                            col: attrName === null || attrName === void 0 ? void 0 : attrName.startCol,
                            raw: attrName === null || attrName === void 0 ? void 0 : attrName.raw,
                        });
                    }
                }
            }
        });
    },
});
function isValueRule(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
value) {
    if (typeof value === 'string') {
        return false;
    }
    if ('enum' in value) {
        if (Object.keys(value).length > 1) {
            return false;
        }
        return true;
    }
    if ('token' in value) {
        return false;
    }
    if ('pattern' in value) {
        return true;
    }
    if (value.type === 'integer' || value.type === 'float') {
        return false;
    }
    if (Object.keys(value).length > 1) {
        return false;
    }
    return true;
}
