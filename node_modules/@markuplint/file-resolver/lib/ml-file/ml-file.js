"use strict";
var _MLFile_basename, _MLFile_code, _MLFile_dirname, _MLFile_stat, _MLFile_type;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLFile = void 0;
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const path_1 = tslib_1.__importDefault(require("path"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const minimatch_1 = require("minimatch");
class MLFile {
    constructor(target) {
        var _a, _b;
        _MLFile_basename.set(this, void 0);
        _MLFile_code.set(this, void 0);
        _MLFile_dirname.set(this, void 0);
        /**
         * - `Stats`: Exists
         * - `null`: Not exists
         * - `undefined`: Doesn't read yet
         */
        _MLFile_stat.set(this, undefined);
        _MLFile_type.set(this, void 0);
        if (typeof target === 'string') {
            tslib_1.__classPrivateFieldSet(this, _MLFile_basename, path_1.default.basename(target), "f");
            tslib_1.__classPrivateFieldSet(this, _MLFile_dirname, path_1.default.dirname(target), "f");
            tslib_1.__classPrivateFieldSet(this, _MLFile_code, null, "f");
            tslib_1.__classPrivateFieldSet(this, _MLFile_type, 'file-base', "f");
            return;
        }
        if (!target.workspace && target.name && path_1.default.isAbsolute(target.name)) {
            tslib_1.__classPrivateFieldSet(this, _MLFile_basename, path_1.default.basename(target.name), "f");
            tslib_1.__classPrivateFieldSet(this, _MLFile_dirname, path_1.default.dirname(target.name), "f");
        }
        else {
            tslib_1.__classPrivateFieldSet(this, _MLFile_basename, (_a = target.name) !== null && _a !== void 0 ? _a : '<AnonymousFile>', "f");
            tslib_1.__classPrivateFieldSet(this, _MLFile_dirname, (_b = target.workspace) !== null && _b !== void 0 ? _b : process.cwd(), "f");
        }
        tslib_1.__classPrivateFieldSet(this, _MLFile_code, target.sourceCode, "f");
        tslib_1.__classPrivateFieldSet(this, _MLFile_type, 'code-base', "f");
    }
    get dirname() {
        return tslib_1.__classPrivateFieldGet(this, _MLFile_dirname, "f");
    }
    /**
     * Normalized `MLFile.dirname`
     */
    get nDirname() {
        return pathNormalize(this.dirname);
    }
    /**
     * Normalized `MLFile.path`
     */
    get nPath() {
        return pathNormalize(this.path);
    }
    get path() {
        return path_1.default.resolve(tslib_1.__classPrivateFieldGet(this, _MLFile_dirname, "f"), tslib_1.__classPrivateFieldGet(this, _MLFile_basename, "f"));
    }
    async dirExists() {
        return !!(await stat(tslib_1.__classPrivateFieldGet(this, _MLFile_dirname, "f")));
    }
    async getCode() {
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_code, "f") != null) {
            return tslib_1.__classPrivateFieldGet(this, _MLFile_code, "f");
        }
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_type, "f") === 'file-base' && (await this.isExist())) {
            return await this._fetch();
        }
        return '';
    }
    ignored(globPath) {
        globPath = typeof globPath === 'string' ? [globPath] : globPath;
        const normalizedPaths = globPath.map(p => pathNormalize(p, true));
        const ig = (0, ignore_1.default)().add(normalizedPaths);
        const ignored = ig.ignores(pathNormalize(this.nPath, true));
        return ignored;
    }
    async isExist() {
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_type, "f") === 'code-base') {
            return true;
        }
        const stat = await this._stat();
        return !!stat;
    }
    async isFile() {
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_type, "f") === 'code-base') {
            return true;
        }
        const stat = await this._stat();
        return !!stat && stat.isFile();
    }
    matches(globPath) {
        return (0, minimatch_1.minimatch)(this.nPath, pathNormalize(globPath));
    }
    setCode(code) {
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_type, "f") === 'file-base') {
            throw new Error(`This file object is readonly (File-base: ${this.path})`);
        }
        tslib_1.__classPrivateFieldSet(this, _MLFile_code, code, "f");
    }
    async _fetch() {
        const code = await fs_1.promises.readFile(this.path, { encoding: 'utf-8' });
        tslib_1.__classPrivateFieldSet(this, _MLFile_code, code, "f");
        return code;
    }
    async _stat() {
        if (tslib_1.__classPrivateFieldGet(this, _MLFile_stat, "f")) {
            return tslib_1.__classPrivateFieldGet(this, _MLFile_stat, "f");
        }
        tslib_1.__classPrivateFieldSet(this, _MLFile_stat, await stat(this.path), "f");
        return tslib_1.__classPrivateFieldGet(this, _MLFile_stat, "f");
    }
}
exports.MLFile = MLFile;
_MLFile_basename = new WeakMap(), _MLFile_code = new WeakMap(), _MLFile_dirname = new WeakMap(), _MLFile_stat = new WeakMap(), _MLFile_type = new WeakMap();
async function stat(filePath) {
    try {
        return await fs_1.promises.stat(filePath);
    }
    catch (err) {
        if (
        // @ts-ignore
        'code' in err &&
            // @ts-ignore
            err.code === 'ENOENT') {
            return null;
        }
        throw err;
    }
}
function pathNormalize(filePath, relative = false) {
    const hasBang = filePath.startsWith('!');
    if (hasBang) {
        filePath = filePath.slice(1);
    }
    // Remove the local disk scheme of Windows OS
    if (path_1.default.isAbsolute(filePath)) {
        filePath = filePath.replace(/^[a-z]+:/i, '');
        if (relative) {
            filePath = path_1.default.relative(path_1.default.sep, filePath);
        }
    }
    // Replace the separator of Windows OS
    filePath = filePath.split(path_1.default.sep).join('/');
    if (hasBang) {
        filePath = `!${filePath}`;
    }
    return filePath;
}
