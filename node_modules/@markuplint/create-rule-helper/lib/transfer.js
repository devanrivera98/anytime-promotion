"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transfer = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = require("node:fs");
const promises_1 = tslib_1.__importDefault(require("node:fs/promises"));
const node_path_1 = require("node:path");
const prettier_1 = require("prettier");
const typescript_1 = require("typescript");
const fs_exists_1 = require("./fs-exists");
const glob_1 = tslib_1.__importDefault(require("./glob"));
async function transfer(scaffoldType, baseDir, destDir, options) {
    const files = await scan(baseDir, destDir);
    const results = [];
    for (const file of files) {
        const result = await transferFile(scaffoldType, file, options);
        if (result) {
            results.push(result);
        }
    }
    return results;
}
exports.transfer = transfer;
async function transferFile(scaffoldType, file, options) {
    var _a, _b;
    if (!(await (0, fs_exists_1.fsExists)(file.filePath))) {
        return null;
    }
    if (file.test && !(options === null || options === void 0 ? void 0 : options.test)) {
        return null;
    }
    let contents = await promises_1.default.readFile(file.filePath, { encoding: 'utf-8' });
    if (options === null || options === void 0 ? void 0 : options.replacer) {
        Object.entries(options === null || options === void 0 ? void 0 : options.replacer).forEach(([before, after]) => {
            if (!after) {
                return;
            }
            // Hyphenation to camel-case for variables
            // `rule-name` => `ruleName`
            contents = contents.replace(new RegExp(`__${before}__c`, 'g'), 
            // Camelize
            after.replace(/-+([a-z])/gi, (_, $1) => $1.toUpperCase()).replace(/^[a-z]/, $0 => $0.toLowerCase()));
            contents = contents.replace(new RegExp(`__${before}__`, 'g'), after);
        });
    }
    // Remove prettier ignore comment
    contents = contents.replace(/\n\s*\/\/ prettier-ignore/, '');
    contents = contents.replace(/\n\s*<!-- prettier-ignore(?:-(?:start|end))? -->/, '');
    const newFile = { ...file };
    if (scaffoldType === 'core' && file.test) {
        const name = (_a = options === null || options === void 0 ? void 0 : options.replacer) === null || _a === void 0 ? void 0 : _a.ruleName;
        if (!name) {
            throw new Error('Rule name is empty');
        }
        newFile.destDir = newFile.destDir.replace(`${node_path_1.sep}rules${node_path_1.sep}src${node_path_1.sep}`, `${node_path_1.sep}rules${node_path_1.sep}test${node_path_1.sep}`);
        contents = contents.replace("require('./').default", `require('../../lib/${name}').default`);
    }
    // TypeScript transpiles to JS
    if (newFile.ext === '.ts' && (options === null || options === void 0 ? void 0 : options.transpile)) {
        newFile.ext = '.js';
        contents = (0, typescript_1.transpile)(contents, {
            target: typescript_1.ScriptTarget.ESNext,
        }, newFile.filePath);
        // Insert new line before comments and the export keyword
        contents = contents.replace(/(\n)(\s+\/\*\*|export)/g, '$1\n$2');
    }
    const candidateName = (_b = options === null || options === void 0 ? void 0 : options.replacer) === null || _b === void 0 ? void 0 : _b[newFile.name.replace(/_/g, '')];
    if (candidateName) {
        newFile.name = candidateName;
        newFile.fileName = candidateName + (newFile.test ? '.spec' : '');
    }
    const dest = (0, node_path_1.resolve)(newFile.destDir, newFile.fileName + newFile.ext);
    // Prettier
    const parser = newFile.ext === '.md'
        ? 'markdown'
        : newFile.ext === '.json'
            ? 'json'
            : newFile.ext === '.ts'
                ? (options === null || options === void 0 ? void 0 : options.transpile)
                    ? 'babel'
                    : 'typescript'
                : undefined;
    contents = await (0, prettier_1.format)(contents, { parser, filepath: dest });
    if (!(await (0, fs_exists_1.fsExists)(newFile.destDir))) {
        await promises_1.default.mkdir(newFile.destDir, { recursive: true });
    }
    await promises_1.default.writeFile(dest, contents, { encoding: 'utf-8' });
    return newFile;
}
async function scan(baseDir, destDir) {
    const fileList = await (0, glob_1.default)((0, node_path_1.resolve)(baseDir, '**', '*'));
    const destList = fileList
        .map(filePath => {
        const stat = (0, node_fs_1.statSync)(filePath);
        if (!stat.isFile()) {
            return null;
        }
        const relPath = (0, node_path_1.relative)(baseDir, filePath);
        const destPath = (0, node_path_1.resolve)(destDir, relPath);
        const ext = (0, node_path_1.extname)(destPath);
        const fileName = (0, node_path_1.basename)(destPath, ext);
        const test = (0, node_path_1.extname)(fileName) === '.spec';
        const name = (0, node_path_1.basename)(fileName, '.spec');
        const destFileDir = (0, node_path_1.dirname)(destPath);
        return {
            ext,
            fileName,
            name,
            test,
            destDir: destFileDir,
            filePath,
        };
    })
        .filter((f) => !!f);
    return destList;
}
