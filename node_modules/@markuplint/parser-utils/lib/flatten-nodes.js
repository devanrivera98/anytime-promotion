"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenNodes = void 0;
const tslib_1 = require("tslib");
const remove_deprecated_node_1 = require("./remove-deprecated-node");
const tag_splitter_1 = tslib_1.__importDefault(require("./tag-splitter"));
const parser_utils_1 = require("@markuplint/parser-utils");
function flattenNodes(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
nodeTree, rawHtml, createLastText = true) {
    var _a, _b, _c, _d;
    const nodeOrders = arrayize(nodeTree, rawHtml);
    {
        /**
         * Correction prev/next/parent
         */
        let prevToken = null;
        for (const node of nodeOrders) {
            if (!prevToken) {
                prevToken = node;
                continue;
            }
            if (node.type !== 'endtag') {
                prevToken = node;
                continue;
            }
            const endTag = node;
            if (endTag.nodeName.toLowerCase() === 'body' && prevToken.type === 'text') {
                const prevWreckagesText = prevToken;
                const wreckages = (0, tag_splitter_1.default)(prevWreckagesText.raw, prevWreckagesText.startLine, prevWreckagesText.startCol);
                if (wreckages.length > 0 && wreckages[0]) {
                    // console.log('wreckages\n', wreckages);
                    const lastText = wreckages[0];
                    const raw = lastText.raw;
                    const startLine = lastText.line;
                    const startCol = lastText.col;
                    prevWreckagesText.raw = raw;
                    prevWreckagesText.endOffset = prevWreckagesText.startOffset + raw.length;
                    prevWreckagesText.startLine = startLine;
                    prevWreckagesText.endLine = (0, parser_utils_1.getEndLine)(raw, startLine);
                    prevWreckagesText.startCol = startCol;
                    prevWreckagesText.endCol = (0, parser_utils_1.getEndCol)(raw, startCol);
                }
            }
        }
    }
    (0, remove_deprecated_node_1.removeDeprecatedNode)(nodeOrders);
    {
        /**
         * getting last node
         */
        let lastNode = null;
        for (const node of nodeOrders) {
            if (node.isGhost) {
                continue;
            }
            lastNode = node;
        }
        if (lastNode) {
            if (lastNode.type === 'text') {
                // Correction for Parse5 AST
                // prev node: ? -> html
                lastNode.prevNode = (_b = (_a = lastNode.parentNode) === null || _a === void 0 ? void 0 : _a.parentNode) !== null && _b !== void 0 ? _b : lastNode.parentNode;
                if (lastNode.prevNode) {
                    lastNode.prevNode.nextNode = lastNode;
                }
                // parent node: body -> null
                lastNode.parentNode = null;
                // next node: ? -> null
                lastNode.nextNode = null;
            }
            else if (createLastText) {
                /**
                 * create Last spaces
                 */
                let lastOffset = 0;
                nodeOrders.forEach((node, i) => {
                    lastOffset = Math.max(node.endOffset, lastOffset);
                });
                // console.log(lastOffset);
                const lastTextContent = rawHtml.slice(lastOffset);
                // console.log(`"${lastTextContent}"`);
                if (lastTextContent) {
                    const line = (_c = lastNode === null || lastNode === void 0 ? void 0 : lastNode.endLine) !== null && _c !== void 0 ? _c : 0;
                    const col = (_d = lastNode === null || lastNode === void 0 ? void 0 : lastNode.endCol) !== null && _d !== void 0 ? _d : 0;
                    const lastTextNode = {
                        uuid: (0, parser_utils_1.uuid)(),
                        raw: lastTextContent,
                        startOffset: lastOffset,
                        endOffset: lastOffset + lastTextContent.length,
                        startLine: line,
                        endLine: (0, parser_utils_1.getEndLine)(lastTextContent, line),
                        startCol: col,
                        endCol: (0, parser_utils_1.getEndCol)(lastTextContent, col),
                        nodeName: '#text',
                        type: 'text',
                        parentNode: null,
                        prevNode: lastNode,
                        nextNode: null,
                        isFragment: false,
                        isGhost: false,
                    };
                    lastNode.nextNode = lastTextNode;
                    if ((lastNode.type === 'starttag' || lastNode.type === 'endtag') && lastNode.pearNode) {
                        lastNode.pearNode.nextNode = lastTextNode;
                    }
                    nodeOrders.push(lastTextNode);
                }
            }
        }
    }
    /**
     * concat text nodes
     */
    const result = [];
    nodeOrders.forEach(node => {
        var _a, _b;
        const prevNode = (_a = result[result.length - 1]) !== null && _a !== void 0 ? _a : null;
        if (node.type === 'text' && (prevNode === null || prevNode === void 0 ? void 0 : prevNode.type) === 'text') {
            prevNode.raw = prevNode.raw + node.raw;
            prevNode.endOffset = node.endOffset;
            prevNode.endLine = node.endLine;
            prevNode.endCol = node.endCol;
            prevNode.nextNode = node.nextNode;
            if (prevNode.parentNode) {
                if (prevNode.parentNode.childNodes) {
                    if (prevNode.parentNode.childNodes.findIndex(currentChild => currentChild.uuid === prevNode.uuid) === -1) {
                        prevNode.parentNode.childNodes.unshift(prevNode);
                    }
                    else {
                        prevNode.parentNode.childNodes = [prevNode];
                    }
                }
                prevNode.parentNode.childNodes = (_b = prevNode.parentNode.childNodes) === null || _b === void 0 ? void 0 : _b.filter(n => n.uuid !== node.uuid);
            }
            if (node.nextNode) {
                node.nextNode.prevNode = prevNode;
            }
            return;
        }
        result.push(node);
    });
    {
        /**
         * Correction prev/next/parent
         */
        let prevToken = null;
        for (const node of result) {
            if (!prevToken) {
                prevToken = node;
                continue;
            }
            if (((prevToken.type === 'endtag' && prevToken.nodeName.toLowerCase() === 'body') ||
                prevToken.type === 'doctype') &&
                node.type === 'text') {
                const nextNode = prevToken.nextNode;
                prevToken.nextNode = node;
                if (prevToken.type === 'endtag' && prevToken.pearNode) {
                    prevToken.pearNode.nextNode = node;
                }
                node.prevNode = prevToken;
                node.nextNode = nextNode;
                node.parentNode = prevToken.parentNode;
            }
            // EndTag
            if (node.type === 'starttag' && node.pearNode) {
                const endTag = node.pearNode;
                endTag.pearNode = node;
                endTag.prevNode = node.prevNode;
                endTag.nextNode = node.nextNode;
            }
            // Children
            if (node.type === 'text') {
                const parent = node.parentNode;
                if (parent && parent.type === 'starttag' && parent.nodeName.toLowerCase() === 'html') {
                    if (parent.childNodes && !parent.childNodes.some(n => n.uuid === node.uuid)) {
                        parent.childNodes.push(node);
                    }
                }
            }
            prevToken = node;
        }
    }
    // console.log(nodeOrders.map((n, i) => `${i}: ${n.raw.trim()}`));
    return result;
}
exports.flattenNodes = flattenNodes;
function arrayize(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
nodeTree, rawHtml) {
    const nodeOrders = [];
    let prevLine = 1;
    let prevCol = 1;
    let currentEndOffset = 0;
    /**
     * pushing list
     */
    (0, parser_utils_1.walk)(nodeTree, node => {
        var _a;
        const diff = node.startOffset - currentEndOffset;
        if (diff > 0) {
            const html = rawHtml.slice(currentEndOffset, node.startOffset);
            /**
             * first white spaces
             */
            if (/^\s+$/.test(html)) {
                const spaces = html;
                const textNode = {
                    uuid: (0, parser_utils_1.uuid)(),
                    raw: spaces,
                    startOffset: currentEndOffset,
                    endOffset: currentEndOffset + spaces.length,
                    startLine: prevLine,
                    endLine: (0, parser_utils_1.getEndLine)(spaces, prevLine),
                    startCol: prevCol,
                    endCol: (0, parser_utils_1.getEndCol)(spaces, prevCol),
                    nodeName: '#text',
                    type: 'text',
                    parentNode: node.parentNode,
                    prevNode: node.prevNode,
                    nextNode: node,
                    isFragment: false,
                    isGhost: false,
                };
                node.prevNode = textNode;
                if (node.parentNode && node.parentNode.childNodes) {
                    const newChildNodes = [...node.parentNode.childNodes];
                    if (newChildNodes.some(child => {
                        return (
                        // Out of start offset
                        textNode.endOffset < child.startOffset ||
                            // Out of end offset
                            child.endOffset < textNode.startOffset);
                    })) {
                        newChildNodes.push(textNode);
                    }
                    newChildNodes.sort((a, b) => a.startOffset - b.startOffset);
                    node.parentNode.childNodes = newChildNodes;
                }
                nodeOrders.push(textNode);
            }
        }
        currentEndOffset = node.startOffset + node.raw.length;
        prevLine = node.endLine;
        prevCol = node.endCol;
        // for ghost nodes
        node.endOffset = (_a = node.endOffset) !== null && _a !== void 0 ? _a : currentEndOffset;
        nodeOrders.push(node);
    });
    return nodeOrders.slice();
}
