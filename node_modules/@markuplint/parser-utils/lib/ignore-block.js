"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.restoreNode = exports.ignoreBlock = void 0;
const const_1 = require("./const");
const create_token_1 = require("./create-token");
const get_location_1 = require("./get-location");
const siblings_correction_1 = require("./siblings-correction");
function ignoreBlock(source, tags, maskChar = const_1.MASK_CHAR) {
    let replaced = source;
    const stack = [];
    for (const tag of tags) {
        // Replace tags in attributes
        const attr = maskText(prepend(tag.start, '(?<=(?:"|\'))'), append(tag.end, '(?=(?:"|\'))'), replaced, (startTag, taggedCode, endTag) => {
            const mask = maskChar.repeat(startTag.length) +
                taggedCode.replace(/[^\n]/g, maskChar) +
                maskChar.repeat((endTag !== null && endTag !== void 0 ? endTag : '').length);
            return mask;
        });
        replaced = attr.replaced;
        stack.push(...attr.stack.map(res => ({ ...res, type: tag.type })));
        // Replace tags in other nodes
        const text = maskText(tag.start, tag.end, replaced, (startTag, taggedCode, endTag) => {
            const mask = maskChar.repeat(startTag.length) +
                taggedCode.replace(/[^\n]/g, maskChar) +
                maskChar.repeat((endTag !== null && endTag !== void 0 ? endTag : '').length);
            const taggedMask = `<!${mask.slice(2).slice(0, -1)}>`;
            return taggedMask;
        });
        replaced = text.replaced;
        stack.push(...text.stack.map(res => ({ ...res, type: tag.type })));
    }
    stack.sort((a, b) => a.index - b.index);
    return {
        source,
        replaced,
        stack,
        maskChar,
    };
}
exports.ignoreBlock = ignoreBlock;
function maskText(start, end, replaced, masking) {
    const stack = [];
    start = removeGlobalOption(start);
    end = removeGlobalOption(end);
    while (start.test(replaced)) {
        const [index, above, startTag, _below] = snap(replaced, start);
        if (!startTag || !_below) {
            continue;
        }
        const [, taggedCode, endTag, below] = snap(_below, end);
        stack.push({
            index,
            startTag,
            taggedCode,
            endTag: endTag !== null && endTag !== void 0 ? endTag : null,
        });
        /**
         * It will not replace line breaks because detects line number.
         */
        replaced = above + masking(startTag, taggedCode, endTag) + (below !== null && below !== void 0 ? below : '');
    }
    return {
        replaced,
        stack,
    };
}
function restoreNode(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
nodeList, ignoreBlock) {
    var _a, _b, _c, _d, _e;
    nodeList = nodeList.slice();
    const { source, stack, maskChar } = ignoreBlock;
    for (const node of nodeList) {
        if (node.type === 'comment' || node.type === 'text' || node.type === 'psblock') {
            if (!hasIgnoreBlock(node.raw, maskChar)) {
                continue;
            }
            const parentNode = node.parentNode;
            const index = nodeList.findIndex(n => n === node);
            const insertList = [];
            let text = node.raw;
            let pointer = 0;
            for (const tag of stack) {
                if (node.startOffset <= tag.index && tag.index < node.endOffset) {
                    const start = tag.index - node.startOffset;
                    const body = tag.startTag + tag.taggedCode + ((_a = tag.endTag) !== null && _a !== void 0 ? _a : '');
                    const above = node.raw.slice(pointer, start);
                    const below = text.slice(above.length + body.length);
                    if (above) {
                        const offset = node.startOffset + pointer;
                        const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = (0, get_location_1.sliceFragment)(source, offset, offset + above.length);
                        const textNode = {
                            ...node,
                            uuid: (0, create_token_1.uuid)(),
                            type: 'text',
                            raw,
                            startOffset,
                            endOffset,
                            startLine,
                            endLine,
                            startCol,
                            endCol,
                        };
                        if ((_b = node.prevNode) === null || _b === void 0 ? void 0 : _b.nextNode) {
                            node.prevNode.nextNode = textNode;
                        }
                        if ((_c = node.nextNode) === null || _c === void 0 ? void 0 : _c.prevNode) {
                            node.nextNode.prevNode = textNode;
                        }
                        insertList.push(textNode);
                    }
                    if (body) {
                        const offset = node.startOffset + pointer + above.length;
                        const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = (0, get_location_1.sliceFragment)(source, offset, offset + body.length);
                        const bodyNode = {
                            uuid: (0, create_token_1.uuid)(),
                            type: 'psblock',
                            nodeName: `#ps:${tag.type}`,
                            raw,
                            parentNode: node.parentNode,
                            prevNode: null,
                            nextNode: null,
                            isFragment: node.isFragment,
                            isGhost: false,
                            startOffset,
                            endOffset,
                            startLine,
                            endLine,
                            startCol,
                            endCol,
                        };
                        if ((_d = node.prevNode) === null || _d === void 0 ? void 0 : _d.nextNode) {
                            node.prevNode.nextNode = bodyNode;
                        }
                        if ((_e = node.nextNode) === null || _e === void 0 ? void 0 : _e.prevNode) {
                            node.nextNode.prevNode = bodyNode;
                        }
                        insertList.push(bodyNode);
                    }
                    text = below;
                    pointer = start + body.length;
                }
            }
            if (text) {
                const offset = node.endOffset - text.length;
                const { raw, startOffset, endOffset, startLine, endLine, startCol, endCol } = (0, get_location_1.sliceFragment)(source, offset, offset + text.length);
                const textNode = {
                    ...node,
                    uuid: (0, create_token_1.uuid)(),
                    type: 'text',
                    raw,
                    startOffset,
                    endOffset,
                    startLine,
                    endLine,
                    startCol,
                    endCol,
                };
                insertList.push(textNode);
            }
            (0, siblings_correction_1.siblingsCorrection)(insertList);
            if (parentNode) {
                parentNode.childNodes = insertList;
            }
            nodeList.splice(index, 1, ...insertList);
        }
        if (node.type === 'starttag') {
            for (const attr of node.attributes) {
                if (attr.type === 'ps-attr' || attr.value.raw === '' || !hasIgnoreBlock(attr.value.raw, maskChar)) {
                    continue;
                }
                for (const tag of stack) {
                    const raw = tag.startTag + tag.taggedCode + tag.endTag;
                    const length = raw.length;
                    if (attr.value.startOffset <= tag.index && tag.index + length <= attr.value.endOffset) {
                        const offset = tag.index - attr.value.startOffset;
                        const above = attr.value.raw.slice(0, offset);
                        const below = attr.value.raw.slice(offset + length);
                        attr.value.raw = above + raw + below;
                        attr.isDynamicValue = true;
                    }
                }
            }
        }
    }
    return nodeList;
}
exports.restoreNode = restoreNode;
function snap(str, reg) {
    const matched = reg.exec(str);
    if (!matched) {
        return [-1, str];
    }
    const index = matched.index;
    const snapPoint = matched[0];
    const above = str.slice(0, index);
    const below = str.slice(index).slice(snapPoint.length);
    return [index, above, snapPoint, below];
}
function removeGlobalOption(reg) {
    return new RegExp(reg.source, reg.ignoreCase ? 'i' : '');
}
function prepend(reg, str) {
    return new RegExp(str + reg.source, reg.ignoreCase ? 'i' : '');
}
function append(reg, str) {
    return new RegExp(reg.source + str, reg.ignoreCase ? 'i' : '');
}
function hasIgnoreBlock(textContent, maskChar) {
    return textContent.includes(maskChar);
}
