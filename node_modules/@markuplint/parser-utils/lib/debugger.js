"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.attributesToDebugMaps = exports.nodeListToDebugMaps = void 0;
function nodeListToDebugMaps(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
nodeList, withAttr = false) {
    return nodeList
        .map(n => {
        const r = [];
        if (!n.isGhost) {
            r.push(tokenDebug(n));
            if (withAttr && 'attributes' in n) {
                r.push(...attributesToDebugMaps(n.attributes).flat());
            }
        }
        else {
            r.push(`[N/A]>[N/A](N/A)${n.nodeName}: ${visibleWhiteSpace(n.raw)}`);
        }
        return r;
    })
        .flat();
}
exports.nodeListToDebugMaps = nodeListToDebugMaps;
function attributesToDebugMaps(
// eslint-disable-next-line @typescript-eslint/prefer-readonly-parameter-types
attributes) {
    return attributes.map(n => {
        const r = [
            tokenDebug({
                ...n,
                name: n.type === 'html-attr' ? n.name.raw : n.raw,
            }),
        ];
        if (n.type === 'html-attr') {
            r.push(`  ${tokenDebug(n.spacesBeforeName, 'bN')}`);
            r.push(`  ${tokenDebug(n.name, 'name')}`);
            r.push(`  ${tokenDebug(n.spacesBeforeEqual, 'bE')}`);
            r.push(`  ${tokenDebug(n.equal, 'equal')}`);
            r.push(`  ${tokenDebug(n.spacesAfterEqual, 'aE')}`);
            r.push(`  ${tokenDebug(n.startQuote, 'sQ')}`);
            r.push(`  ${tokenDebug(n.value, 'value')}`);
            r.push(`  ${tokenDebug(n.endQuote, 'eQ')}`);
            r.push(`  isDirective: ${!!n.isDirective}`);
            r.push(`  isDynamicValue: ${!!n.isDynamicValue}`);
        }
        if (n.potentialName != null) {
            r.push(`  potentialName: ${visibleWhiteSpace(n.potentialName)}`);
        }
        if (n.type === 'html-attr' && n.candidate) {
            r.push(`  candidate: ${visibleWhiteSpace(n.candidate)}`);
        }
        return r;
    });
}
exports.attributesToDebugMaps = attributesToDebugMaps;
function tokenDebug(n, type = '') {
    var _a, _b, _c, _d;
    return `[${n.startLine}:${n.startCol}]>[${n.endLine}:${n.endCol}](${n.startOffset},${n.endOffset})${
    // @ts-ignore
    (_d = (_c = (_b = (_a = n.potentialName) !== null && _a !== void 0 ? _a : n.nodeName) !== null && _b !== void 0 ? _b : n.name) !== null && _c !== void 0 ? _c : n.type) !== null && _d !== void 0 ? _d : type}: ${visibleWhiteSpace(n.raw)}`;
}
function visibleWhiteSpace(chars) {
    return chars.replace(/\n/g, '⏎').replace(/\t/g, '→').replace(/\s/g, '␣');
}
