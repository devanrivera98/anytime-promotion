"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tokenize = exports.parseAttr = exports.defaultValueDelimiters = void 0;
const create_token_1 = require("./create-token");
exports.defaultValueDelimiters = [
    {
        start: "'",
        end: "'",
    },
    {
        start: '"',
        end: '"',
    },
];
const defaultEqual = '=';
const spaceRegex = /^\s$/;
function parseAttr(raw, offset, html, options) {
    const tokens = tokenize(raw, options);
    tokens.beforeName;
    const attrToken = (0, create_token_1.createTokenFromRawCode)(raw, offset, html);
    const spacesBeforeName = (0, create_token_1.tokenizer)(tokens.beforeName, attrToken.startLine, attrToken.startCol, attrToken.startOffset);
    const name = (0, create_token_1.tokenizer)(tokens.name, spacesBeforeName.endLine, spacesBeforeName.endCol, spacesBeforeName.endOffset);
    const spacesBeforeEqual = (0, create_token_1.tokenizer)(tokens.afterName, name.endLine, name.endCol, name.endOffset);
    const equal = (0, create_token_1.tokenizer)(tokens.equal, spacesBeforeEqual.endLine, spacesBeforeEqual.endCol, spacesBeforeEqual.endOffset);
    const spacesAfterEqual = (0, create_token_1.tokenizer)(tokens.beforeValue, equal.endLine, equal.endCol, equal.endOffset);
    const startQuote = (0, create_token_1.tokenizer)(tokens.startQuote, spacesAfterEqual.endLine, spacesAfterEqual.endCol, spacesAfterEqual.endOffset);
    const value = (0, create_token_1.tokenizer)(tokens.value, startQuote.endLine, startQuote.endCol, startQuote.endOffset);
    const endQuote = (0, create_token_1.tokenizer)(tokens.endQuote, value.endLine, value.endCol, value.endOffset);
    const attr = {
        type: 'html-attr',
        uuid: (0, create_token_1.uuid)(),
        raw: attrToken.raw,
        startOffset: attrToken.startOffset,
        endOffset: attrToken.endOffset,
        startLine: attrToken.startLine,
        endLine: attrToken.endLine,
        startCol: attrToken.startCol,
        endCol: attrToken.endCol,
        spacesBeforeName,
        name,
        spacesBeforeEqual,
        equal,
        spacesAfterEqual,
        startQuote,
        value,
        endQuote,
        isDuplicatable: false,
        nodeName: name.raw,
        parentNode: null,
        nextNode: null,
        prevNode: null,
        isFragment: false,
        isGhost: false,
    };
    return attr;
}
exports.parseAttr = parseAttr;
function tokenize(raw, options) {
    var _a, _b, _c;
    const valueDelimiters = (_a = options === null || options === void 0 ? void 0 : options.valueDelimiters) !== null && _a !== void 0 ? _a : exports.defaultValueDelimiters;
    const equalDelimiter = (_b = options === null || options === void 0 ? void 0 : options.equal) !== null && _b !== void 0 ? _b : defaultEqual;
    let state = 'b-name';
    const charactors = raw.split('');
    let beforeName = '';
    let name = '';
    let afterName = '';
    let equal = '';
    let valueDelimiter = null;
    let beforeValue = '';
    let startQuote = '';
    let value = '';
    let endQuote = '';
    let afterAttr = '';
    while (charactors.length > 0) {
        const charactor = charactors.shift();
        if (state === 'b-name') {
            if (spaceRegex.test(charactor)) {
                beforeName += charactor;
                continue;
            }
            name += charactor;
            state = 'name';
            continue;
        }
        if (state === 'name') {
            if (equalDelimiter === charactor) {
                equal = equalDelimiter;
                state = 'value-start';
                continue;
            }
            if (spaceRegex.test(charactor)) {
                afterName += charactor;
                state = 'a-name';
                continue;
            }
            name += charactor;
            continue;
        }
        if (state === 'a-name') {
            if (equalDelimiter === charactor) {
                equal = equalDelimiter;
                state = 'value-start';
                continue;
            }
            if (spaceRegex.test(charactor)) {
                afterName += charactor;
                continue;
            }
            break;
        }
        if (state === 'value-start') {
            if (spaceRegex.test(charactor)) {
                beforeValue += charactor;
                continue;
            }
            valueDelimiter = (_c = valueDelimiters.find(d => d.start === charactor)) !== null && _c !== void 0 ? _c : null;
            if (valueDelimiter) {
                startQuote += valueDelimiter.start;
            }
            else {
                value += beforeValue + charactor;
                beforeValue = '';
            }
            state = 'value';
            continue;
        }
        if (state !== 'value') {
            throw new Error('ParseError: unknown parse state in the attribute');
        }
        value += charactor;
    }
    if (valueDelimiter) {
        const endQuoteIndex = value.lastIndexOf(valueDelimiter.end);
        endQuote = value.slice(endQuoteIndex, endQuoteIndex + 1);
        afterAttr = value.slice(endQuoteIndex + 1);
        value = value.slice(0, endQuoteIndex);
    }
    return {
        beforeName,
        name,
        afterName,
        equal,
        beforeValue,
        startQuote,
        value,
        endQuote,
        afterAttr,
    };
}
exports.tokenize = tokenize;
