"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const parser_utils_1 = require("@markuplint/parser-utils");
const reAttrsInStartTag = 
// eslint-disable-next-line no-control-regex
/(\s*)([^\x00-\x1f\x7f-\x9f "'>/=]+)(?:(\s*)(=)(\s*)(?:(?:"([^"]*)")|(?:'([^']*)')|([^\s]*)))?/;
function attrTokenizer(raw, line, col, startOffset) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const attrMatchedMap = raw.match(reAttrsInStartTag);
    if (!attrMatchedMap) {
        throw new SyntaxError('Illegal attribute token');
    }
    const spacesBeforeAttrString = (_a = attrMatchedMap[1]) !== null && _a !== void 0 ? _a : '';
    const nameChars = (_b = attrMatchedMap[2]) !== null && _b !== void 0 ? _b : '';
    const spacesBeforeEqualChars = (_c = attrMatchedMap[3]) !== null && _c !== void 0 ? _c : '';
    const equalChars = (_d = attrMatchedMap[4]) !== null && _d !== void 0 ? _d : null;
    const spacesAfterEqualChars = (_e = attrMatchedMap[5]) !== null && _e !== void 0 ? _e : '';
    const quoteChars = attrMatchedMap[6] != null ? '"' : attrMatchedMap[7] != null ? "'" : null;
    const valueChars = (_h = (_g = (_f = attrMatchedMap[6]) !== null && _f !== void 0 ? _f : attrMatchedMap[7]) !== null && _g !== void 0 ? _g : attrMatchedMap[8]) !== null && _h !== void 0 ? _h : (quoteChars ? '' : null);
    let offset = startOffset;
    const spacesBeforeName = (0, parser_utils_1.tokenizer)(spacesBeforeAttrString, line, col, offset);
    line = spacesBeforeName.endLine;
    col = spacesBeforeName.endCol;
    offset = spacesBeforeName.endOffset;
    const name = (0, parser_utils_1.tokenizer)(nameChars, line, col, offset);
    line = name.endLine;
    col = name.endCol;
    offset = name.endOffset;
    const spacesBeforeEqual = (0, parser_utils_1.tokenizer)(spacesBeforeEqualChars, line, col, offset);
    line = spacesBeforeEqual.endLine;
    col = spacesBeforeEqual.endCol;
    offset = spacesBeforeEqual.endOffset;
    const equal = (0, parser_utils_1.tokenizer)(equalChars, line, col, offset);
    line = equal.endLine;
    col = equal.endCol;
    offset = equal.endOffset;
    const spacesAfterEqual = (0, parser_utils_1.tokenizer)(spacesAfterEqualChars, line, col, offset);
    line = spacesAfterEqual.endLine;
    col = spacesAfterEqual.endCol;
    offset = spacesAfterEqual.endOffset;
    const startQuote = (0, parser_utils_1.tokenizer)(quoteChars, line, col, offset);
    line = startQuote.endLine;
    col = startQuote.endCol;
    offset = startQuote.endOffset;
    const value = (0, parser_utils_1.tokenizer)(valueChars, line, col, offset);
    line = value.endLine;
    col = value.endCol;
    offset = value.endOffset;
    const endQuote = (0, parser_utils_1.tokenizer)(quoteChars, line, col, offset);
    const attrToken = (0, parser_utils_1.tokenizer)(nameChars +
        spacesBeforeEqualChars +
        (equalChars !== null && equalChars !== void 0 ? equalChars : '') +
        spacesAfterEqualChars +
        (quoteChars !== null && quoteChars !== void 0 ? quoteChars : '') +
        (valueChars !== null && valueChars !== void 0 ? valueChars : '') +
        (quoteChars !== null && quoteChars !== void 0 ? quoteChars : ''), name.startLine, name.startCol, name.startOffset);
    return {
        type: 'html-attr',
        uuid: (0, parser_utils_1.uuid)(),
        raw: attrToken.raw,
        startOffset: attrToken.startOffset,
        endOffset: attrToken.endOffset,
        startLine: attrToken.startLine,
        endLine: attrToken.endLine,
        startCol: attrToken.startCol,
        endCol: attrToken.endCol,
        spacesBeforeName,
        name,
        spacesBeforeEqual,
        equal,
        spacesAfterEqual,
        startQuote,
        value,
        endQuote,
        isDuplicatable: false,
        nodeName: name.raw,
        parentNode: null,
        prevNode: null,
        nextNode: null,
        isFragment: false,
        isGhost: false,
    };
}
exports.default = attrTokenizer;
