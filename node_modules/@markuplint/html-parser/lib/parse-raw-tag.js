"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const parser_utils_1 = require("@markuplint/parser-utils");
const attr_tokenizer_1 = tslib_1.__importDefault(require("./attr-tokenizer"));
// eslint-disable-next-line no-control-regex
const reAttrsInStartTag = /\s*[^\x00-\x1f\x7f-\x9f "'>/=]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^\s]*))?/;
const reEndTokens = /(\s*\/)?(\s*)>$/;
function parseRawTag(raw, startLine, startCol, startOffset, offsetOffset = 0, offsetLine = 0, offsetColumn = 0) {
    var _a, _b;
    let offset = startOffset + offsetOffset;
    let line = startLine + offsetLine;
    let col = startCol + (startLine === 1 ? offsetColumn : 0);
    const matches = raw.match(parser_utils_1.reTag);
    const tagWithAttrs = matches === null || matches === void 0 ? void 0 : matches[1];
    if (!tagWithAttrs) {
        throw new SyntaxError(`Invalid tag syntax: "${raw}"`);
    }
    // eslint-disable-next-line no-control-regex
    const tagNameSplitted = tagWithAttrs.split(/[\u0000\u0009\u000A\u000C\u0020/>]/);
    const tagName = tagNameSplitted[0] || tagNameSplitted[1];
    if (!tagName || (!parser_utils_1.reTagName.test(tagName) && !(0, parser_utils_1.isPotentialCustomElementName)(tagName))) {
        throw new SyntaxError(`Invalid tag name: "${tagName}" in <${tagWithAttrs}>`);
    }
    const tagStartPos = tagWithAttrs.indexOf(tagName);
    let rawAttrs = tagWithAttrs.substring(tagStartPos + tagName.length);
    // console.log({ raw, tagStartPos, tagName, rawAttrs });
    col += tagName.length + 1 + tagStartPos;
    offset += tagName.length + 1 + tagStartPos;
    const attrs = [];
    while (reAttrsInStartTag.test(rawAttrs)) {
        const attrMatchedMap = rawAttrs.match(reAttrsInStartTag);
        if (attrMatchedMap && attrMatchedMap[0]) {
            const rawAttr = attrMatchedMap[0];
            const attr = (0, attr_tokenizer_1.default)(rawAttr, line, col, offset);
            line = attr.endLine;
            col = attr.endCol;
            offset = attr.endOffset;
            rawAttrs = rawAttrs.substr(rawAttr.length);
            attrs.push(attr);
        }
    }
    const endTokens = reEndTokens.exec(raw);
    const selfClosingSolidus = (0, parser_utils_1.tokenizer)((_a = endTokens === null || endTokens === void 0 ? void 0 : endTokens[1]) !== null && _a !== void 0 ? _a : '', line, col, offset);
    line = selfClosingSolidus.endLine;
    col = selfClosingSolidus.endCol;
    offset = selfClosingSolidus.endOffset;
    const endSpace = (0, parser_utils_1.tokenizer)((_b = endTokens === null || endTokens === void 0 ? void 0 : endTokens[2]) !== null && _b !== void 0 ? _b : '', line, col, offset);
    return {
        tagName,
        attrs,
        selfClosingSolidus,
        endSpace,
    };
}
exports.default = parseRawTag;
